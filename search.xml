<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ThreadLocal]]></title>
    <url>%2F2018%2F09%2F04%2FThreadLocal%2F</url>
    <content type="text"><![CDATA[定义Threadlocal提供了线程本地的变量，这些变量绑定于自己的线程，独立的进行初始化。使用上通常是private static 变量，并且关联一个有状态的变量，如user ID 或Transaction ID. 通常是保存 线程中的状态的变量 例如： 123456789101112131415161718public class ThreadId &#123; // Atomic integer containing the next thread ID to be assigned private static final AtomicInteger nextId = new AtomicInteger(0); // Thread local variable containing each thread's ID private static final ThreadLocal&lt;Integer&gt; threadId = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return nextId.getAndIncrement(); &#125; &#125;; // Returns the current thread's unique ID, assigning it if necessary public static int get() &#123; return threadId.get(); &#125;&#125; 只要这个线程活着，并且threadllocal实例可用，那么每一个线程保持一个引用与threadlocal中变量的拷贝， 使用原理分析注意点参考文献http://www.jasongj.com/java/threadlocal/#comments https://segmentfault.com/a/1190000014738647]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>threadlocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[概述 CLass类以及获取方法 类加载器ClassLoader 反射创建运行的类、获取属性与构造方法、 反射应用：动态代理、AOP 概述反射就是在运行时动态的获取类的属性和方法并调用 CLass类以及获取方法Class类任何语言使用其编译器把程序代码编译(javac.exe)成Class文件,然后通过类加载器(java.exe)加载Class文件到内存(堆内存？)中，这个运行时类就是一个Class的实例，最后通过字节码执行引擎来对方法调用与字节码执行。 特点 每一个运行类只加载一次 有了Class类实例，可以进行以下操作 创建对应的运行类的对象 获取对应的运行类的完整结构 调用对应的运行时类的指定的结构 反射应用：动态代理 Class获取方法 调用类本身的.class属性 1Class clazz = Persion.class; 运行时类的对象获取 12Persion p = new Persion();Class clazz = p.getClass(); 通过Class的静态方法获取（反射的动态性） 123String className = "com.cwm.Persion";Class clazz = Class.forName(className);//执行初始化静态代码块 通过类加载器 123ClassLoader classLoader = this.getClass().getClassLoader();Class clazz = classLoader.loadClass(className);//类还没有链接 加载，链接、初始化 类加载器ClassLoaderClass类实例操作创建运行时类对象1clazz.newInstance(); 获取运行类完整结构属性 方法 构造器 内部类 父类 所在包 注解 异常 调用运行类指定结构反射应用：动态代理、AOP动态代理AOPInvoke深度解析 人吧 缺点 消耗系统资源，什么资源？ 反射调用方法会忽略权限检查，破坏封装性 参考文献 https://www.sczyh30.com/tags/Reflection/ https://blog.csdn.net/love_gaohz/article/details/79905444 https://juejin.im/post/598ea9116fb9a03c335a99a4 https://www.cnblogs.com/mengdd/archive/2013/01/26/2878124.html https://www.zhihu.com/question/24304289]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
        <tag>classloader</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-xml配置文件的解析流程]]></title>
    <url>%2F2018%2F08%2F21%2Fspring-xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[加载xml配置文件,将bean注册到Map中 obtainFreshBeanFactoryorg.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory 12345678protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; refreshBeanFactory(); ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (logger.isDebugEnabled()) &#123; logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory); &#125; return beanFactory;&#125; refreshBeanFactory org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory 12345678910protected final void refreshBeanFactory() &#123; DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); //加载xml配置文件，具体子ApplicationContext loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125;&#125; loadBeanDefinitions有不同的实现类 XmlWebApplicationContext默认的spring容器 org.springframework.web.context.support.XmlWebApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory) 12345678910111213protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory)&#123; // 创建XmlBeanDefinitionReader，用它来读取XML配置文件 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // 配置beanDefinitionReader的环境和属性等 beanDefinitionReader.setEnvironment(getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // 初始化beanDefinitionReader，子类可以实现这个方法，做一些个性化配置和初始化 initBeanDefinitionReader(beanDefinitionReader); // 开始load xml文件 loadBeanDefinitions(beanDefinitionReader);&#125; 12345678910protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) &#123; //读取web.xml中的contextConfigLocation元素，没有读默认 String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; for (String configLocation : configLocations) &#123; //reader读取xml文件 reader.loadBeanDefinitions(configLocation); &#125; &#125;&#125; 1234567891011121314151617181920212223242526public int loadBeanDefinitions(EncodedResource encodedResource) &#123; //将Resource对象添加到hashSet中 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( "Detected cyclic loading of " + encodedResource + " - check your import definitions!"); &#125; InputStream inputStream = encodedResource.getResource().getInputStream(); InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // 加载封装好的inputSource对象，读取XML配置文件 return doLoadBeanDefinitions(inputSource, encodedResource.getResource());&#125;finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125;&#125;&#125; 1234567protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) &#123; //将xml转为Document Document doc = doLoadDocument(inputSource, resource); //Document转换为BeanDefinition并注册到BeanDefinitionMap return registerBeanDefinitions(doc, resource);&#125; 1private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;(64); 创建一个转换器实例然后调用注册benaDefinitions 1234567public int registerBeanDefinitions(Document doc, Resource resource) &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); documentReader.setEnvironment(getEnvironment()); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 1234567891011121314151617181920protected void doRegisterBeanDefinitions(Element root) &#123; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; return; &#125; &#125; &#125; preProcessXml(root); //装换文档中的标签 parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;&#125; 1234567891011121314151617181920protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 12345public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123; String namespaceUri = getNamespaceURI(ele); NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; 各种方法的标签解析，如何选择的呢？ 12345678910111213NamespaceHandler SimplePropertyNamespaceHandler SimpleConstructorNamespaceHandler NamespaceHandlerSupport JeeNamespaceHandler AopNamespaceHandler ContextNamespaceHandler LangNamespaceHandler UtilNamespaceHandler MvcNamespaceHandler TaskNamespaceHandler CacheNamespaceHandler TxNamespaceHandler]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-bean的创建和初始化]]></title>
    <url>%2F2018%2F08%2F21%2Fspring-bean%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[反射创建bean以及初始化 12345678910111213141516171819202122232425protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; // I初始化conversionService类型转换bean，它可以服务于其他bean的类型转换 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; //// 初始化LoadTimeWeaverAware bean String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; // Stop using the temporary ClassLoader for type matching. //// 停止使用临时的ClassLoader， beanFactory.setTempClassLoader(null); // Allow for caching all bean definition metadata, not expecting further changes. beanFactory.freezeConfiguration(); // Instantiate all remaining (non-lazy-init) singletons. //创建和初始化非lazy-init的singleton beans beanFactory.preInstantiateSingletons();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public void preInstantiateSingletons() throws BeansException &#123; // Iterate over a copy to allow for init methods which in turn register new bean definitions. // While this may not be part of the regular factory bootstrap, it does otherwise work fine. // 获取XML配置文件解析时，解析到的所有beanname List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames); // 遍历所有没有标注lazy-init的singleton的beanname,创建bean for (String beanName : beanNames) &#123; //利用beanname获取BeanDefinition，在XML解析时会生成BeanDefinition对象， //将XML中的各属性添加到BeanDefinition的相关标志位中，比如abstractFlag，scope等 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 非abstract，非lazy-init的singleton bean才需要在容器初始化阶段创建 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; // 处理FactoryBean if (isFactoryBean(beanName)) &#123; // 获取FactoryBean实例，FactoryBean前面会加一个&amp;符号 final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123; @Override public Boolean run() &#123; return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(); &#125; &#125;, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; // 非Factorybean,直接调用getBean方法 if (isEagerInit) &#123; getBean(beanName); &#125; &#125; else &#123; getBean(beanName); &#125; &#125; &#125; // Trigger post-initialization callback for all applicable beans... // bean创建后，对SmartInitializingSingleton回调afterSingletonsInstantiated()方法 for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125; &#125;&#125; 123public Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false);&#125; doGetBean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; //beanname转换，去掉FactoryBean的&amp;前缀，处理alias声明 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; // 判断singleton bean是否已经创建好了，创建好了则直接从内存取出。 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125;else &#123; // Fail if we're already creating this bean instance: // We're assumably within a circular reference. if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. //检查是否有beanname对应的BeanDefinition BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // 没有找到BeanDefinition，看看parent工厂中有没有，调用parent工厂的getBean // 获取原始的name，包含了FactoryBean前缀，&amp;符号 String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; // 找到了beanname对应的BeanDefinition，合并parent的BeanDefinition(XML中的parent属性) final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. // 处理dependsOn属性 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; // 遍历所有的dependOn bean，要先注册和创建依赖的bean for (String dependsOnBean : dependsOn) &#123; // check是否两个bean是循环依赖，spring不能出现bean的循环依赖 if (isDependent(beanName, dependsOnBean)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dependsOnBean + "'"); &#125; // 注册并创建依赖的bean registerDependentBean(dependsOnBean, beanName); getBean(dependsOnBean); &#125; &#125; // Create bean instance. // 处理scope属性 if (mbd.isSingleton()) &#123; // singleton, 必须保证线程安全情况下创建bean，保证单例 sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; // 反射创建bean实例 return createBean(beanName, mbd, args); &#125; &#125;); // 获取bean实例 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125;else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; // 创建前的回调 beforePrototypeCreation(beanName); // 反射创建bean实例 prototypeInstance = createBean(beanName, mbd, args); &#125;finally &#123; // 创建后的回调，清除inCreation的标志 afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125;else &#123; // 其他scope值 String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; &#125;&#125;&#125;// check 创建的bean是否是requiredType指明的类型。如果不是，先做转换，转换不成的话只能类型不匹配抛出异常了if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123; // 尝试将创建的bean转换为requiredType指明的类型 return getTypeConverter().convertIfNecessary(bean, requiredType); &#125;return (T) bean;&#125; 123456789101112131415161718protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)&#123; // Make sure bean class is actually resolved at this point. // 拷贝一个新的RootBeanDefinition供创建bean使用 resolveBeanClass(mbd, beanName); // Prepare method overrides. //处理bean中定义的覆盖方法，主要是xml:lookup-method或replace-method。 //标记override的方法为已经加载过的，避免不必要的参数检查开销 mbd.prepareMethodOverrides(); // 调用BeanPostProcessors bean后处理器，使得bean后处理器可以返回一个proxy bean， //从而代替我们要创建的bean。回调后处理器的postProcessBeforeInstantiation()方法，如果这个方法中返回了一个bean，也就是使用了proxy，则再回调postProcessAfterInitialization()方法。之后返回这个Proxy bean即可。 Object bean = resolveBeforeInstantiation(beanName, mbd); if (bean != null) &#123; return bean; &#125; // doCreateBean创建bean实例 Object beanInstance = doCreateBean(beanName, mbd, args); return beanInstance;&#125; doCreateBean1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123; // 创建bean实例，如果是singleton，先尝试从缓存中取，取不到则创建 BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; // 反射创建bean实例 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); // Allow post-processors to modify the merged bean definition. // 回调MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition，它可以修改bean属性 synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. // 曝光单例对象的引用，主要是为了解决单例间的循环依赖问题，以及依赖的bean比较复杂时的初始化性能问题 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references"); &#125; addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // 初始化bean Object exposedObject = bean; populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; // 单例曝光对象的处理 if (earlySingletonExposure) &#123; Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException; &#125; &#125; &#125; &#125; // Register bean as disposable. // 注册bean为可销毁的bean，bean销毁时，会回调destroy-method registerDisposableBeanIfNecessary(beanName, bean, mbd); return exposedObject;&#125; createBeanInstance1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123; // Make sure bean class is actually resolved at this point. // 先创建class对象，反射的套路。利用bean的class属性进行反射，所以class属性一定要是bean的实现类 Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); // class如果不是public的，则抛出异常。因为没法进行实例化 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Bean class isn't public, and non-public access not allowed: " + beanClass.getName()); &#125;// 使用FactoryBean的factory-method来创建，支持静态工厂和实例工厂 if (mbd.getFactoryMethodName() != null) &#123; return instantiateUsingFactoryMethod(beanName, mbd, args); &#125; // Shortcut when re-creating the same bean... // 无参数情况时，创建bean。调用无参构造方法 boolean resolved = false; boolean autowireNecessary = false; if (args == null) &#123; synchronized (mbd.constructorArgumentLock) &#123; if (mbd.resolvedConstructorOrFactoryMethod != null) &#123; resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; &#125; &#125; &#125; if (resolved) &#123; if (autowireNecessary) &#123; // autoWire创建 自动装配 return autowireConstructor(beanName, mbd, null, null); &#125; else &#123; // 普通创建 return instantiateBean(beanName, mbd); &#125; &#125; // Need to determine the constructor... // 有参数情况时，创建bean。先利用参数个数，类型等，确定最精确匹配的构造方法。 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; return autowireConstructor(beanName, mbd, ctors, args); &#125; // No special handling: simply use no-arg constructor. // 有参数时，又没获取到构造方法，则只能调用无参构造方法来创建实例了(兜底方法) return instantiateBean(beanName, mbd);&#125; 12345678910111213141516171819protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123; Object beanInstance; final BeanFactory parent = this; if (System.getSecurityManager() != null) &#123; beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; // 创建实例 return getInstantiationStrategy().instantiate(mbd, beanName, parent); &#125; &#125;, getAccessControlContext()); &#125; else &#123; beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); &#125; BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw;&#125; instantiate1234567891011121314151617181920212223242526272829303132333435363738public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123; // Don't override the class with CGLIB if no overrides. if (bd.getMethodOverrides().isEmpty()) &#123; Constructor&lt;?&gt; constructorToUse; // 保证线程安全情况下，获取Constructor synchronized (bd.constructorArgumentLock) &#123; // 获取构造方法或factory-method constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) &#123; // BeanDefinition中如果没有Constructor或者factory-method，则直接使用默认无参构造方法 final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) &#123; throw new BeanInstantiationException(clazz, "Specified class is an interface"); &#125; if (System.getSecurityManager() != null) &#123; constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123; @Override public Constructor&lt;?&gt; run() throws Exception &#123; return clazz.getDeclaredConstructor((Class[]) null); &#125; &#125;); &#125; else &#123; // 获取默认无参构造方法 constructorToUse = clazz.getDeclaredConstructor((Class[]) null); &#125; bd.resolvedConstructorOrFactoryMethod = constructorToUse; &#125; &#125; // 使用上一步得到的Constructor，反射获取bean实例 return BeanUtils.instantiateClass(constructorToUse); &#125; else &#123; // Must generate CGLIB subclass. return instantiateWithMethodInjection(bd, beanName, owner); &#125;&#125; instantiate方法主要做两件事 确定Constructor或者factory-method 利用Constructor，反射创建bean实例 initializeBeanbean创建完后，容器会对它进行初始化，包括后处理的调用，init-method的调用等 1234567891011121314151617181920212223242526protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; // 回调各种aware method，如BeanNameAware， BeanFactoryAware等 if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; // 回调init-method invokeAwareMethods(beanName, bean); &#125; // 回调beanPostProcessor的postProcessBeforeInitialization()方法 Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; invokeInitMethods(beanName, wrappedBean, mbd); if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 由此可见，initializeBean(),也就是bean的初始化流程为 回调各种aware method，如BeanNameAware，将容器中相关引用注入到bean中，供bean使用 回调beanPostProcessor的postProcessBeforeInitialization(), 后处理器的初始化前置调用 回调init-method， 注解和XML中都可以声明 回调beanPostProcessor的postProcessAfterInitialization()方法，后处理器的初始化后置调用。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring启动流程]]></title>
    <url>%2F2018%2F08%2F21%2Fspring%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[web容器加载web.xml中的ContextLoaderListener 初始化spring容器 加载配置文件，创建bean Web.xmlweb容器为spring提供了宿主环境Servletcontext,启动时读取web.xml/包括ContextLoaderListener启动spring容器、DispathcherServlet springmvc分发器， 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!--web项目中上下文初始化参数, name value的形式 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--ContextLoaderListener,会通过它的监听启动spring容器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--DispatherServlet,前端MVC核心，分发器，SpringMVC的核心--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;/web-app&gt; web容器的初始化过程： web容器（如tomcat）读取web.xml, 读取文件中两个节点和 容器创建ServletContext，它是web的上下文，整个web项目都会用到它 读取context-param节点，它以 键值对的形式出现。将节点值转化为键值对，传给ServletContext 容器创建中的实例，创建监听器。监听器必须继承ServletContextListener 调用ServletContextListener的contextInitialized()方法，spring容器的创建和初始化就是在这个方法中 initWebApplicationContext初始化spring容器，使用默认的配置文件，或者context-params中的配置contextConfigLocation org.springframework.web.context.ContextLoader#initWebApplicationContext 123456789101112131415161718192021222324252627282930313233343536373839404142public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123; long startTime = System.currentTimeMillis(); // Store context in local instance variable, to guarantee that // it is available on ServletContext shutdown. //创建WebApplicationContext if (this.context == null) &#123; this.context = createWebApplicationContext(servletContext); &#125; if (this.context instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc // 判断context有没有父context， //取决于web.xml配置文件中locatorFactorySelector参数，如果有父context，则加载它 if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; // determine parent for root web application context, if any. ApplicationContext parent = loadParentContext(servletContext); cwac.setParent(parent); &#125; // refresh容器，这一步会创建beans configureAndRefreshWebApplicationContext(cwac, servletContext); &#125; &#125; // 将spring容器context，挂载到servletContext这个web容器全局变量中。ServletContext是web容器的上下文 //web容器指的是Tomcat等部署web应用的容器，不要和spring容器搞混了 servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); // 将spring容器context赋值给currentContext变量，保存下来 ClassLoader ccl = Thread.currentThread().getContextClassLoader(); if (ccl == ContextLoader.class.getClassLoader()) &#123; currentContext = this.context; &#125; else if (ccl != null) &#123; currentContextPerThread.put(ccl, this.context); &#125; log..... return this.context;&#125; initWebApplicationContext()主要做三件事 创建WebApplicationContext，通过createWebApplicationContext()方法 加载spring配置文件，并创建beans。通过configureAndRefreshWebApplicationContext()方法 将spring容器context挂载到ServletContext 这个web容器上下文中。通过servletContext.setAttribute()方法。 createWebApplicationContext 创建spring容器初始化root webAppLicationContext，采用默认配置或者自定义的class 1234567891011protected WebApplicationContext createWebApplicationContext(ServletContext sc) &#123; // 获取WebApplicationContext实现类的class对象，WebApplicationContext只是一个接口，需要有具体的实现类，默认的实现类是XmlWebApplicationContext Class&lt;?&gt; contextClass = determineContextClass(sc); // 自定义WebApplicationContext必须继承自ConfigurableWebApplicationContext if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException("Custom context class [" + contextClass.getName() + "] is not of type [" + ConfigurableWebApplicationContext.class.getName() + "]"); &#125; // 由class对象创建实例对象 return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);&#125; configureAndRefreshWebApplicationContext 加载spring配置文件，创建beans12345678910111213141516171819protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123; wac.setId(idParam); wac.setServletContext(sc); String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM); if (configLocationParam != null) &#123; wac.setConfigLocation(configLocationParam); &#125; // The wac environment's #initPropertySources will be called in any case when the context // is refreshed; do it eagerly here to ensure servlet property sources are in place for // use in any post-processing or initialization that occurs below prior to #refresh //加载属性到enviroment ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) &#123; ((ConfigurableWebEnvironment) env).initPropertySources(sc, null); &#125; //个性化配置 customizeContext(sc, wac); wac.refresh();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243//读取配置文件、并创建和初始化beanspublic void refresh()&#123; // Prepare this context for refreshing. //准备工作，设置ApplicationContext中的一些标志位，如closed设为false,activer为true,等 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. //读取spring xml配置文件， ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. //设置容器beanfactory的各种成员属性，比如beanCLassLoader,beanPostProcessors //这里的beanPostProcessor都是系统默认的，不是用户自定义的。比如负责注入ApplicationContext引用到各种Aware中的ApplicationContextAwareProcessor容器后处理器。 prepareBeanFactory(beanFactory); // Allows post-processing of the bean factory in context subclasses. // 调用默认的容器后处理器，如ServletContextAwareProcessor postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 初始化并调用所有注册的容器后处理器BeanFactoryPostProcessor invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. // 注册bean后处理器，将实现了BeanPostProcessor接口的bean找到。 //先将实现了PriorityOrdered接口的bean排序并注册到容器BeanFactory中， //然后将实现了Ordered接口的排序并注册到容器中，最后注册剩下的。 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. // 初始化MessageSource，用来处理国际化。 //如果有beanName为“messageSource”，则初始化。否则使用默认的。 initMessageSource(); // Initialize event multicaster for this context. // 初始化ApplicationEventMulticaster，用来进行事件广播。 //如果有beanName为"applicationEventMulticaster"，则初始化它。否则使用默认的SimpleApplicationEventMulticaster。广播事件会发送给所有监听器，也就是实现了ApplicationListener的类 //关于spring事件体系，可以参见 http://blog.csdn.net/caihaijiang/article/details/7460888 initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. // 初始化其他特殊的bean。子类可以override这个方法。如WebApplicationContext的themeSource onRefresh(); // Check for listener beans and register them. // 注册事件监听器，也就是所有实现了ApplicationListener的类。会将监听器加入到事件广播器ApplicationEventMulticaster中，所以在广播时就可以发送消息给所有监听器了。 registerListeners(); // 初始化所有剩下的singleton bean(没有标注lazy-init的) finishBeanFactoryInitialization(beanFactory); // 回调LifecycleProcessor，发送ContextRefreshedEvent事件等 finishRefresh();&#125; 参考文献https://blog.csdn.net/u013510838/article/details/75066884 https://blog.csdn.net/moshenglv/article/details/53517343 http://www.cnblogs.com/ITtangtang/p/3978349.html http://www.linkedkeeper.com/1054.html]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc基本原理]]></title>
    <url>%2F2018%2F08%2F21%2Fspringmvc%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Spring 面试题 Spring MVC基本原理 总结 Spring 面试题 什么是Spring框架，主要模块 好处 IOC,DI BeanFactory和ApplicationContext有什么区别 Spring Bean的生命周期 Spring框架中的单例bean是线程安全的吗 Spring MVC基本原理配置阶段web.xmlDispatcherServlet:Springweb开发的入口 application.xml配置spring启动所需要的加载的bean url-pattern拦截的地址 初始化阶段servlet的init方法由web容器自动调用servlet的init方法，在init方法中，执行初始化操作 加载配置文件加载application.xml，扫包，将className收集起来 初始化IOC容器就是一个map&lt;String,Object&gt; IOC容器规则 key默认都是类名首字母小写 如果用户自定义名字，那么要优先设为该名字 如果是接口，使用接口类型作为key,vlaue为实现类 依赖注入@Autowried 遍历IOC容器中class的属性，是否有注解，将其与容器中的关联 初始化handlermapping map&lt;String,handler&gt;,存储requestmapping配置的url等 list中存储映射关系，包括正则url,参数， 将ioc中被controller注解的class中的url作为baseUrl，其中的方法为url后缀 远行阶段servlet.service(Request,Response)线程阻塞，用户请求，封装参数，反射自动调用方法 request.getURL()获得用户请求的URL 匹配URL和对应的Method调用method封装参数，反射动态调用method 利用Response将调用结果输出到浏览器]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用linux命令]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%B8%B8%E7%94%A8linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux 实用命令： 帮助命令 :man,help 文件目录类：pwd\ls\cd\mkdir\rmdir\touch\cp\rm\mv\cat\more\less\echo\head\tail\ln\history 时间日期类：date\cal 搜索查找类：find\locate\grep 压缩和解压类：gzip\tar 帮助命令man,help 文件目录类定位：pwd\ls\cd\ 目录操作mkdir\rmdir\touch\cp\rm\mv\ 查看less\echo\head\tail\ln\history 时间日期类date\cal 搜索查找类find\locate\grep 压缩和解压类​ gzip\tar]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Guava学习笔记]]></title>
    <url>%2F2018%2F08%2F05%2FGoogle-Guava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介 基本工具 集合Collections 缓存Caches 函数式风格 并发Concurrency 字符串处理Strings 原生类型 区间Ranges I/O hash 事件总线EventBus 数学运算Math 反射Reflections 简介源码包的简单说明 com.google.common.annotations：普通注解类型。 com.google.common.base：基本工具类库和接口。 使用和避免使用null 前置条件：快速失败 常见的对象方法：简化Object常用方法的实现 排序：fluent comparator比较器，提供多关键字排序 Throwable类：简化异常检查和错误传播 com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存 com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类 Immutable collections(不变的集合)：不可修改的集合 新集合类型：multisets，multimaps，tables， bidirectional maps等 集合工具类 拓展工具类：给集合对象添加功能 com.google.common.eventbus：发布订阅风格的事件总线。 com.google.common.hash： 哈希工具包。 com.google.common.io：I/O工具包。 com.google.common.math：原始算术类型和超大数的运算工具包。 com.google.common.net：网络工具包。 com.google.common.primitives：八种原始类型和无符号类型的静态工具包。 com.google.common.reflect：反射工具包。 com.google.common.util.concurrent：多线程工具包。 基本工具Optional 类：使用和避免使用null参见java8 Optional 前置条件：快速失败常见的对象方法：简化Object常用方法的实现排序：fluent comparator比较器，提供多关键字排序Throwable类：简化异常检查和错误传播集合Immutable collections(不变的集合)新集合类型：集合工具类拓展工具类：给集合对象添加功能缓存函数式风格并发ListenableFutureService字符串处理原生类型区间I/Ohash事件总线数学运算反射参考文献 官网 https://github.com/google/guava/wiki 并发编程网 http://ifeve.com/google-guava/ http://www.cnblogs.com/peida/p/Guava.htm]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Powermockto]]></title>
    <url>%2F2018%2F08%2F04%2FPowermockto%2F</url>
    <content type="text"><![CDATA[mock是模拟对象，用于模拟真实对象的行为powermock拓展了esaymock和mockito框架，增加了对static 和final方法mock支持等功能， 本文阐述powermockto简单用法，未包含 answer,spy,captor等 jar包123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt; &lt;version&gt;1.6.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-api-mockito&lt;/artifactId&gt; &lt;version&gt;1.6.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; mock流程 创建一个mock对象 期望：记录希望mock对象有的行为，通常是伪造的部分 回放（replay）：调用我们的测试的代码 验证（Verfications）:验证结果注解概述@RunWith(PowerMockRunner.class)12345@Before public void initMocks() &#123; //注解初始化 MockitoAnnotations.initMocks(this); &#125; @PrepareForTest({Student.class})如果mock的对象的方法是静态、final、私有方法，将类加到注解数组中 @Mockmock的对象，mock创建一个空白实例，没有属性没有方法 @InjectMocksmock对象自动注入到该测试类中,尝试类型注入，如果有多个类型的mock对象，那么会根据名称进行注入，当注入失败的时候，不会抛出异常 mock普通方法12345678910111213141516171819public class T1 &#123; public boolean isExist(File file)&#123; return file.exists(); &#125;&#125;@Test public void test1()&#123; T1 t1 = PowerMockito.mock(T1.class); when(t1.isExist(any())).thenReturn(true); //会真实的调用，但是返回的是mock的内容，如果不想调用的话 T1 t1 =spy(T1.class);; PowerMockito.doReturn(true).when(t1).isExist(any()); assertTrue(t1.isExist(new File("xx.xml"))); &#125;//不需要写注解 模拟静态方法123456789101112131415161718public class T1 &#123; public static boolean isExist(String path)&#123; File file = new File(path); return file.exists(); &#125;&#125;@RunWith(PowerMockRunner.class)@PrepareForTest(T1.class)public class testMock &#123; @Test public void test1() throws Exception &#123; PowerMockito.mockStatic(T1.class); when(T1.isExist(any())).thenReturn(true); assertTrue(T1.isExist("xx")); &#125;&#125; 模拟final类或方法12345678910111213141516171819public class T1 &#123; public final boolean isExist(String path)&#123; File file = new File(path); return file.exists(); &#125;&#125;@RunWith(PowerMockRunner.class)@PrepareForTest(T1.class)//加注解表明final的类public class testMock &#123; @Test public void test1() throws Exception &#123; T1 t1 = PowerMockito.mock(T1.class); when(t1.isExist(any())).thenReturn(true); assertTrue(t1.isExist("xx")); &#125;&#125; 构造函数1234567891011121314151617181920212223public class T1 &#123; public boolean isExist(String path)&#123; File file = new File(path); return file.exists(); &#125;&#125;@RunWith(PowerMockRunner.class)@PrepareForTest(T1.class)public class testMock &#123; @Test public void test1() throws Exception &#123; T1 t1 = new T1(); File file = PowerMockito.mock(File.class); //使用whenNew 构造file返回值，需要添加两个注解 whenNew(File.class).withAnyArguments().thenReturn(file); when(file.exists()).thenReturn(true); assertTrue(t1.isExist("xx.xml")); &#125;&#125; 模拟私有方法123456789101112131415161718192021public class T1 &#123; private boolean isExist(String path)&#123; File file = new File(path); return file.exists(); &#125; public boolean Exist(String path)&#123; return isExist(path); &#125;&#125;@RunWith(PowerMockRunner.class)@PrepareForTest(T1.class)public class testMock &#123; @Test public void test1() throws Exception &#123; T1 t1 = PowerMockito.mock(T1.class); when(t1.Exist("xx")).thenCallRealMethod(); when(t1,"isExist","xx").thenReturn(true); assertTrue(t1.Exist("xx")); &#125;&#125; verfications验证方法调用Mockito.verify(mock).create()验证调用了create方法。 Mockito.verify(mock, Mockito.never()).update();验证没有调用update方法。 验证调用次数Mockito.times(int n) : 准确的验证方法调用的次数:n Mockito.atLeastOnce() : 验证方法至少调用1次 Mockito.atLeast(int n) : 验证方法最少调用n次 Mockito.atMost(int n): 验证方法最多调用n次 Mockito.inOrder:验证方法调用的顺序 原理简述 当某个方法被注解@PrepareForTest注解后，启动该测试用例，会创建一个新的MockclassLoader实例，然后加载测试用例用到的类（系统类除外） 加载过程中，会根据mock请求修改mock的class文件，eg,去掉final标识，修改方法体 对于系统类，会修改调用系统类的class文件，不会直接修改系统类class 参考文献 https://www.cnblogs.com/IamThat/p/5072499.html https://blog.csdn.net/qisibajie/article/details/79068086#mockito%E5%92%8Cpowermock%E7%9A%84%E7%94%A8%E6%B3%95 http://hotdog.iteye.com/blog/937862 https://blog.csdn.net/vipshop_fin_dev/article/details/79439334]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8学习笔记]]></title>
    <url>%2F2018%2F08%2F01%2Fjava8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Lambda表达式 函数式接口 方法引用和构造器引用 Stream APi 接口中的默认方法与静态方法 新时间日期API 其他新特性 新特性简介 速度更快 hashmap 1.7数组链表 1.8数组链表-红黑树 ConcurrentHashMap 1.7 分段锁 1.8cas无锁算法 内存结构变化 1.7方法区是永久区的一部分，存放加载的类信息等 1.8把永久区去掉了，并将方法区叫做元空间MetaSpace,并使用物理内存 代码更少（Lambda表达式） 强大的Stream API（像sql一样简单） 便于并行 最大化减少空指针异常Optional Lambda为什么使用Lambda是一个匿名函数=====一段可以传递的代码 example1: 123456789//匿名内部类Comparator&lt;Integer&gt; com = new Comparator&lt;Integer&gt;()&#123; public int compare(Integer o1,Integer o2)&#123; return Integer.compare(o1,o2); &#125;&#125;;//lambdaComparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y);TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(com); example 2: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class TestLambda &#123; /** * 一堆员工中工资大于900的 * 一堆员工中工资大于900的，但是年龄小于18岁的 */ /** * 方案1： * 遍历，各种遍历 * 方案2： * 策略模式以及优化的匿名内部类 * 方案3： * java8函数式编程 */ List&lt;Persion&gt; persions ; @Before public void testBefore()&#123; persions = Arrays.asList( new Persion("zs",16,1299), new Persion("ls",19,799), new Persion("ww",17,1999), new Persion("zl",20,1999), new Persion("tq",18,699) ); &#125; //方案1 @Test public void test1()&#123; ArrayList&lt;Persion&gt; result = new ArrayList&lt;Persion&gt;(); for (Persion p : this.persions) &#123; if(p.getSalary()&gt;800)&#123; result.add(p); &#125; &#125; System.out.println(JSONObject.toJSONString(result)); //如果再加条件，那么就再一个方法遍历多个条件，缺点：代码重复，核心代码没几行 &#125; //方案2 @Test public void test2()&#123; MyPredicate&lt;Persion&gt; myPredicate = new MyPredicate&lt;Persion&gt;() &#123; public boolean test(Persion persion) &#123; return persion.getSalary()&gt;900; &#125; &#125;; ArrayList&lt;Persion&gt; result = new ArrayList&lt;&gt;(); for (Persion p : this.persions) &#123; if(myPredicate.test(p))&#123; result.add(p); &#125; &#125; System.out.println(JSONObject.toJSONString(result)); //主逻辑不需要变，但是还需要写接口之类的 &#125; @Test public void test3()&#123; MyPredicate&lt;Persion&gt; myPredicate = persion -&gt; persion.getSalary()&gt;900; ArrayList&lt;Persion&gt; result = new ArrayList&lt;&gt;(); for (Persion p : this.persions) &#123; if(myPredicate.test(p))&#123; result.add(p); &#125; &#125; result.forEach( System.out::println); &#125;&#125; Lambda 基本语法语法格式： 无参数，无返回值 runable example 1//匿名内部类的final问题 有一个参数，无返回值 consume example 有多个参数，有返回值，多条语句 Comparator example 函数式接口接口中只有一个抽象方法的接口，称为函数式接口 @FuncationInterface 对一个数进行运算 example 123456@FuncationInterfaceinterface MyFun&#123; Integer getValue()&#125;//接口 lambda 实现 四大内置核心函数式接口 函数式接口 参数类型 返回类型 用途 Consumer 消费型接口 T void 对类型为T的对象应用操作,包含方法 void accept(T t) Supplier供给型接口 无 T 返回类型为T的对象，包含方法：T get() Function&lt;T,R&gt; 函数型接口 T R 对类型为T的对象应用操作，并返回结果为类型R的对象，包含方法：R apply(T t) Predicate 断言型接口 T boolean 确定类型为T的对象是否满足某约束，并返回boolean值，包含方法 boolean test(T t) 方法引用，构造器引用，数组引用方法引用​ 若Lambda体中的内容有方法已经实现了，我们可以使用“方法引用”（可以理解为方法引用是Lambda表达式的另外一种表现形式） 语法格式可以使用方法引用的前提是 实现的接口的参数和返回值 与 调用方法的参数与返回值一样 对象：：实例方法名 类：：静态方法名 类：：实例方法名 第一个参数是方法的调用者，第二个是方法的参数值 example 123456789101112131415161718@Test public void test5()&#123; Consumer&lt;String&gt; con = (s) -&gt; System.out.println(s); PrintStream out = System.out; Consumer&lt;String&gt; con1 = out :: println; &#125; @Test public void test6()&#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x,y); Comparator&lt;Integer&gt; com1 = Integer::compare; &#125; @Test public void test7()&#123; BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y); BiPredicate&lt;String,String&gt; bp1 = String::equals; &#125; 构造器引用语法格式CLassName:: new 需要调用的构造器的参数列表要与函数式接口中方法的参数列表保持一致 12345@Test public void test8()&#123; Supplier&lt;Persion&gt; sup = ()-&gt;new Persion(); Supplier&lt;Persion&gt; sup1 = Persion::new; &#125; 数组引用语法格式Type:new 12345@Test public void test10()&#123; Function&lt;Integer,String[]&gt; fun = (x) -&gt; &#123;new String[x]&#125;; Function&lt;Integer,String[]&gt; fun1 = String[]::new; &#125; Stream是java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤、和映射数据等操作。 数据源：集合、数组等 管道：流水线式的中间操作，筛选、切片等 产生一个新流（终端操作）：跟原数据源没有关系 注意： 不会存储元素 不会改变原对象 延迟执行，需要执行结果才执行 创建Stream方法 通过Collection系列集合提供的stream（）、parallelStream()(串行流和并行流) 通过Arrays中的静态方法stream()获取数组流 通过Stream中的静态方法of(T t) 创建无限流 迭代，Stream.iterator(seed,unaryOPerator) 生成，Stream.generator… 并行流与串行流并行流就是把一个内容分成一个多个数据库，并用不同的线程分别处理每个数据块的流，可以声明式的通过parallel()与sequential()在并行流与顺序流之间进行切换。联系Fork/Join框架。 中间操作筛选与切片 方法 描述 filter(Predicate p) 接收Lambda,从流中排除某些元素 distinct() 筛选，通过流所生成元素的hashcode()和equals去除重复元素 limit(long maxSize) 截断，使元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流，与limit(n)互补 映射将流中的元素通过函数映射为其他流 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每一个元素上，并将其映射一个新的元素 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream mapToint(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStremam mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream flatMap(Function f) 接收一个函数作为参数，将流中的每个值换成另外一个流，然后把所有的流连接成一个流 排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator comp) 产生一个新流，其中按比较器顺序排序 终端操作终端操作会从流的流水线生成结果，其结果可以是任何不是流的值，例如，list,Integer,void等 查找与匹配 方法 描述 addMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Preducate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findany() 返回当前流中的任意元素 归约与收集 方法 描述 reduce(T identity,BinaryOperatore)、reduce(BinaryOperator) 将流中元素反复结合起来，得到一个值 collect(Collector c) 将流转换为其他形式，接收一个Collector接口是实现，用于给Stream中元素做汇总 optional容器类代表一个值存在或不存在，原来用null表示一个值不存在，现在Optional 可以更好的表达这个概念，并且可以避免空指针异常。 常用方法 方法 描述 Optional.of(T) 创建指定引用的Optional实例，若引用为null则快速失败 Optional.absent() 创建一个空的Optional实例 Optional.ofNullable() 若t不为null,创建Optinal实例，否则创建空实例 boolean isPresent() 判断是否包含值 T orElse(T other) 如果调用对象包含值，返回值，否则返回other T orElseGet(Supplier&lt;? extends T&gt; other) 如果调用对象包含值，返回该值，否则返回other获取到的值 Optional map(Function&lt;? super T, ? extends U&gt; mapper) 如果有值对其处理，并返回处理后的optinal,否则返回Optional.empty() Optional flatMap(Function&lt;? super T, Optional&gt; mapper) 与map类似 有点鸡肋，麻烦的狠 接口优化默认方法 实现多接口，如果都有默认方法实现，必须在当前的类中对方法进行覆写 静态方法接口中可以有静态方法 日期时间API代办 重复注解与类型注解重复注解：在一个类上重复定义一个注解，该注解的注解需要标注为@Repeatables]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet学习笔记]]></title>
    <url>%2F2018%2F07%2F30%2FServlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[servlet 容器 Servlet体系结构 servlet容器常见的Servlet容器是tomcat，jetty等 tomcat容器模型 tomcat容器分为四个等级，真正管理servlet的容器是Context容器，一个Context对应一个web工程 tomcat添加一个web项目12345678910111213public Context addWebapp(Host host, String url, String path) &#123; //silence(url); Context ctx = new StandardContext(); ctx.setPath( url );//设置访问路径 ctx.setDocBase(path);//设置项目路径 ctx.setRealm(new NullRealm());//设置权限 ctx.addLifecycleListener(new Tomcat.DefaultWebXmlListener()); ContextConfig ctxCfg = new ContextConfig(); ctx.addLifecycleListener(ctxCfg); ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML"); host.addChild(ctx);//添加到host父容器中 return ctx; &#125; tomcat 启动容器初始化应用初始化 主要是解析web.xml文件，解析文件中的属性保存到WebXML对象中， 然后将WebXML对象中的属性设置到Context中，这里包括Servlet，filter,listener等 Servlet将被包装成Context容器中的StandardWrapper，其具有容器的特征，转换将使得开发者不需要强耦合tomcat 创建servlet实例 创建Servlet对象 如果Servlet的load-on-startup配置项大于0，那么context容器启动的时候就会被实例化，例如DefaultServlet和JSPServlet 调用wrapper.loadServlet方法：获取servletclasss交给instanceManager去创建一个机遇servletclass.class对象 初始化Servlet 调用servlet的init方法，同时把包装了Standandwrapper对象de standardwrapperfacade作为servletconfig传给Servlet Servlet体系结构servlet​ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。 与servlet主动关联的三个类：Servletconfig、servletRequest和ServletResponse,这三个类都是通过容器传递给Servlet的。servletconfig是在servlet是Serevlet初始化时候 传递，后两个是请求到达的时候传递过来的。 Servletconfig接口声明的方法是为了获取Servlet的一些配置信息，包括servletcontext ServletRequest和ServletResponse是请求响应使用,由tomcat将请求封装为org.apache.coyote.Request ，交给一个用户线程处理请求会创建org.apache.catalina.connector. Request ，穿越整个Servlet容器直到传给Servlet，传递给的是request的门面类requestfacade servletconfig standardwrapper和standardwrapperfacade都实现了servletconfig接口，而standwrapperfacade是门面类，传递给servlet,这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet servletconfg 湖区servletcontext的实际对象是ApplicationContextFacade对象，对容器数据的封装 参考文献Servlet 工作原理解析 https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[listener学习笔记]]></title>
    <url>%2F2018%2F07%2F30%2FListener%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[listener定义，以及三大分类等 定义监听器listener就是在application、session\request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件 分类 类型 接口方法 接收事件 ServletContextListener 接口 Servlet上下文事件 contextInitialized() 与 contextDestroyed() ServletContextEvent ServletContextAttributeListene Servlet上下文事件 attributeAdded() 、 attributeReplaced() 、 attributeRemoved() ServletContextAttributeEvent HttpSessionListener 会话事件 sessionCreated() 与 sessionDestroyed () HttpSessionEvent HttpSessionAttributeListener 会话事件 attributeAdded() 、 attributeReplaced() 、 attributeRemoved() HttpSessionBindingEvent HttpSessionActivationListener 会话事件 sessionDidActivate() 与 sessionWillPassivate() HttpSessionEvent HttpSessionBindingListener 会话事件 valueBound() 与 valueUnbound() ServletRequestListener 请求事件 requestInitialized() 与 requestDestroyed() RequestEvent ServletRequestAttributeListener 请求事件 attributeAdded() 、 attributeReplaced() 、 attributeRemoved() ServletRequestAttributeEvent 举例在web.xml中添加 123&lt; listener &gt; &lt; listener -class &gt; com.servlet .listener .YouAchieveListener &lt; /listener -class &gt;&lt; /listener &gt; 在线人数思路：配置listener实现httpsessionListener,sessionCreated的时候执行 spring启动12345678&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;&lt;!-- 采用的是通配符方式，查找WEB-INF/spring目录下xml文件。如有多个xml文件，以“,”分隔。 --&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; ​ ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。 ContextLoaderListener如何查找ApplicationContext.xml的配置位置以及配置多个xml：如果在web.xml中不写任何参数配置信息，默认的路径是”/WEB-INF/applicationContext.xml”，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml（在MyEclipse中把xml文件放置在src目录下）。如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数。 原理观察者模式的实现，在web。xml中配置listener的时候就是把一个被观察者放入到观察者对象列表中，当被观察者触发了注册事件时观察者作出相应的反应。在容器container中注册呼叫特定的实现类 参考文献https://my.oschina.net/ydsakyclguozi/blog/398403 https://www.cnblogs.com/hellojava/archive/2012/12/26/2833840.html http://even2012.iteye.com/blog/1963467]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter学习笔记]]></title>
    <url>%2F2018%2F07%2F30%2FFilter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro学习笔记-流程]]></title>
    <url>%2F2018%2F07%2F29%2Fshiro%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介 Apache Shiro是Java的一个安全（权限）框架 可以在JavaSE，javaEE环境 功能点：认证，授权，加密、会话管理、web集成、缓存等 http://shiro.apache.org/introduction.html shiro架构应用程序角度 Shiro内部架构]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ContextLoaderListener & DispatcherServlet]]></title>
    <url>%2F2018%2F07%2F29%2FContextLoaderListener-DispatcherServlet%2F</url>
    <content type="text"><![CDATA[ContextLoaderListener, DispatcherServlet都会加载配置文件, 那么二者之间有什么区别？ 两个配置文件之间的差异，各定义什么bean 两个类的继承体系结构 两个配置文件生成的容器之间的关系 Spring 与 web.xmlspring 提供了强大的IOC能力，我们往往会配置业务层，数据层的bean在容器中；除此之外，spring 特提供了spring mvc，控制前段发送的请求，在web.xml中往往会有以下的代码片段。 1234567891011121314151617181920&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:*-context.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;servlet&gt; &lt;servlet-name&gt;platform-services&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:platform-services-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;... ContextLoadListener ContextLoaderListener加载设置的配置文件, 联系ServletContextListener监听器 DispatcherServlet DispatcherServlet记载设置的配置文件, 联系ServletConfig ContextLoaderListener​ 继承体系结构 ContextLoaderListener继承ContextLoader, 实现了ServletContextListener接口. 因此在Web容器启动的时候, 其会监听到ServletContext创建事件, 进而进行初始化操作, 其加载配置文件的本质工作是通过ContextLoader来实现的。 ​ initWebApplicationContext()根据指定的xml文件初始化root WebAppicationContext. 在没有设置的,即自定有 上下文初始化类的情况下, 默认采用XmlWebApplicationContex来初始化Spring容器. 此容器是root容器, 里面一般包含应用程序可以共享的bean, 例如 业务层, 数据层, 工具层等等, 往往不会涉及到Web相关的组件, 如视图解析器, 控制器….. root容器被设置在ServletContext中 12345678910111213public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123; public ContextLoaderListener(WebApplicationContext context) &#123; super(context); &#125; /** * Initialize the root web application context. */ @Override public void contextInitialized(ServletContextEvent event) &#123; initWebApplicationContext(event.getServletContext()); &#125; &#125; DispatcherServlet​ 集成体系结构 从集成体系结构可以看出, DispatcherServlet本质上市基于Servlet, 因此也就包含Servlet的生命周期方法, 例如, init(), getServletConfig(), service() HttpServletBean读取web.xml中的DispatcherServlet的配置信息, ; 同时留给子类一些接口实现其他的功能 FramewordServlet则是初始化web application context, 每一个DIspatcherServlet都有一个与之对应的web application context. 其父类是ContextLoader初始化的 Spring上下文(root web application context) DispatcherServlet则用户初始化Spring MVC框架其他的组件, 如HandlerMapping…. 1234HttpServlet HttpServletBean FramewordServlet DispactherServlet 两者初始化的上下文之间的关系​ 上下文的关系如下 父子关系, Spring允许用户建立容器之间的多级关系, 子容器(DispatcherServlet初始化的容器)在本容器中找不到Bean时, 将会去父容器中查找. 父容器中的bean将 在所有子容器之间共享。 常见问题 同一个Bean初始化多遍 将root web application context与web application context的配置信息放在一起 一个bean不仅使用注解, 也使用xml配置以便 在拦截器或者监听器中使用XmlWebApplicationContext加载配置文件….]]></content>
      <categories>
        <category>spring framework</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>servlet</tag>
        <tag>listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客]]></title>
    <url>%2F2018%2F07%2F28%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[在github pages搭建hexo风格的博客，next主题,多电脑方便使用 搭建全新的博客安装git，github创建个人仓库用户名.github.io 安装node.js官网下载地址：https://nodejs.org/zh-cn/download/ 安装成功后在命令窗输node –version显示版本号 安装Hexohttps://zhuanlan.zhihu.com/p/26625249 添加搜索功能http://www.itfanr.cc/2017/10/27/add-search-function-to-hexo-blog/ 修改宽度https://www.heqiangfly.com/2016/01/12/blog-optimize-next-theme/ 关于我页面http://www.5isjyx.com/coding/201704/hexonextabout.html 分类与标签https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/ 评论https://www.bluelzy.com/articles/use_valine_for_your_blog.html 阅读次数http://www.yangyong.xyz/2018/01/03/add-hexo-next-post-views/ 新电脑搭建博客https://www.titanjun.top/2018/04/12/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86/ 目前的操作 clone hexo分支 （新电脑） npm install（新电脑） 写博客 hexo n “博客名” hexo g 生成博客 hexo s启动网站 hexo d发布到master 提交hexo内容到hexo分支 关于写博客的注意事项： 摘要 1234标题：。。。摘要内容。。。&lt;!-- more --&gt;内容。。。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来聊啊]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[微信]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>

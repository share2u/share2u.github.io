<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[shiro工作流程]]></title>
    <url>%2F2018%2F11%2F01%2Fshiro%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[基本描述 Apache Shiro是Java的一个安全（权限）框架 可以在JavaSE，javaEE环境 功能点：认证，授权，加密、会话管理、web集成、缓存等 应用程序角度 Shiro内部架构 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344public class UserRealm extends AuthorizingRealm &#123; private UserService userService; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; // 从数据库中获取权限信息 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; String username = (String)principals.getPrimaryPrincipal(); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); // 从数据库中查询当前用户所拥有的角色 authorizationInfo.setRoles(userService.findRoles(username)); // 从数据库中查询当前用户所拥有的权限 authorizationInfo.setStringPermissions(userService.findPermissions(username)); return authorizationInfo; &#125; // 从数据库中获取认证信息 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; String username = (String)token.getPrincipal(); User user = userService.findByUsername(username); if(user == null) &#123; throw new UnknownAccountException();//没找到帐号 &#125; if(Boolean.TRUE.equals(user.getLocked())) &#123; throw new LockedAccountException(); //帐号锁定 &#125; //交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，如果觉得人家的不好可以自定义实现 SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo( user.getUsername(), //用户名 principal user.getPassword(), //密码 hashedCredentials //注册的时候生成盐值 credentialsSalt ByteSource.Util.bytes(user.getCredentialsSalt()),//salt=username+salt getName() //realmName ); return authenticationInfo; &#125; &#125; 工作流程入口：DelegatingFilterProxyweb.xml中的shiro入口 123456789101112&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; DelegatingFilterProxy 是Filter的代理，代理的是spring容器中的filter-name一样的bean, 12345678910111213141516171819&lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;property name="successUrl" value="/loginsuccess"/&gt; &lt;property name="unauthorizedUrl" value="/unauthorized.jsp"/&gt; &lt;!-- 配置哪些页面需要受保护，以及访问这些页面需要的权限 过滤实现 anon 可以被匿名访问 authc 必须认证后才可以访问的页面 --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; /loginsuccess = anon ===AnonymousFilter /logout = logout /user.jsp = roles[user]====RolesAuthorizationFilter /** = authc ====FormAuthenticationFilter &lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 初始化：shiroFilter ShiroFilterFactoryBean 实现了spring FactoryBean ,getObject获取实例 1234567public Object getObject() throws Exception &#123; if (this.instance == null) &#123; this.instance = this.createInstance(); &#125; return this.instance;&#125; 123456789101112protected AbstractShiroFilter createInstance() throws Exception &#123; log.debug("Creating Shiro Filter instance."); //1、安全管理器 SecurityManager securityManager = this.getSecurityManager(); //2、过滤器链管理器 FilterChainManager manager = this.createFilterChainManager(); //3、基于路径匹配的过滤器链解析器 PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver(); chainResolver.setFilterChainManager(manager); //返回shirofilter对象到spring容器中 return new ShiroFilterFactoryBean.SpringShiroFilter((WebSecurityManager)securityManager, chainResolver);&#125; property filterChainDefinitions 属性，会调用setFilterChainDefinitions 1234567public void setFilterChainDefinitions(String definitions) &#123; Ini ini = new Ini(); ini.load(definitions); //section key为url,value 为filter名称 Section section = ini.getSection("urls"); this.setFilterChainDefinitionMap(section);&#125; SecurityManagerFilterChainManager12345678910111213141516171819202122232425262728293031323334353637protected FilterChainManager createFilterChainManager() &#123; //创建DefaultFilterChainManager，添加默认的filters到manager DefaultFilterChainManager manager = new DefaultFilterChainManager(); //设置默认Filter的基本属性 Map&lt;String, Filter&gt; defaultFilters = manager.getFilters(); for (Filter filter : defaultFilters.values()) &#123; //设置相关FilterURL的loginurl,successurl,unauthorizedUrl属性 applyGlobalPropertiesIfNecessary(filter); &#125; //获取在spring配置文件中的配置的Filter，eg:logout Map&lt;String, Filter&gt; filters = getFilters(); if (!CollectionUtils.isEmpty(filters)) &#123; for (Map.Entry&lt;String, Filter&gt; entry : filters.entrySet()) &#123; String name = entry.getKey(); Filter filter = entry.getValue(); applyGlobalPropertiesIfNecessary(filter); if (filter instanceof Nameable) &#123; ((Nameable) filter).setName(name); &#125; // 将配置的Filter添加至manager中，如果同名Filter已存在则覆盖默认Filter manager.addFilter(name, filter, false); &#125; &#125; //配置的FilterChainDefinition Map&lt;String, String&gt; chains = this.getFilterChainDefinitionMap(); if (!CollectionUtils.isEmpty(chains)) &#123; for (Map.Entry&lt;String, String&gt; entry : chains.entrySet()) &#123; String url = entry.getKey(); String chainDefinition = entry.getValue(); // 为配置的每一个URL匹配创建FilterChain定义， // 这样当访问一个URL的时候，一旦该URL配置上则就知道该URL需要应用上哪些Filter // 由于URL配置符会配置多个，所以以第一个匹配上的为准，所以越具体的匹配符应该配置在前面，越宽泛的匹配符配置在后面 manager.createChain(url, chainDefinition); &#125; &#125; return manager;&#125; DefaultFilterChainManager12345public DefaultFilterChainManager() &#123; this.filters = new LinkedHashMap&lt;String, Filter&gt;(); this.filterChains = new LinkedHashMap&lt;String, NamedFilterList&gt;(); addDefaultFilters(false);&#125; 12345protected void addDefaultFilters(boolean init) &#123; for (DefaultFilter defaultFilter : DefaultFilter.values()) &#123; addFilter(defaultFilter.name(), defaultFilter.newInstance(), init, false); &#125;&#125; DefaultFilter 过滤器11个 1234567891011anon(AnonymousFilter.class),authc(FormAuthenticationFilter.class),authcBasic(BasicHttpAuthenticationFilter.class),logout(LogoutFilter.class),noSessionCreation(facion ico.class),perms(PermissionsAuthorizationFilter.class),port(PortFilter.class),rest(HttpMethodPermissionFilter.class),roles(RolesAuthorizationFilter.class),ssl(SslFilter.class),user(UserFilter.class); filterChains过滤器链是一个linkedhashmap,key为配置的url,value为对应的过滤器 PathMatchingFilterChainResolver创建了新的filterchainfilter,然后又被前面创建的覆盖了，有问题！！！ 基于ant路径匹配方法匹配配置的url, pathMatchingFilterChainResolver设置创建的FilterChainManager对象，所以URL匹配上后可以获取该URL需要应用的FilterChain了。 filter执行—匹配filter(错误)通过请求的url,获取要走的过滤链，或者说，所有请求都走一样的过滤链，过滤器中由判断自己是否支持该请求 （正解）,所有的请求走一个过滤器org.springframework.web.filter.DelegatingFilterProxy#doFilter 12345org.apache.shiro.web.servlet.OncePerRequestFilter#doFilter==执行被代理类doFilter org.apache.shiro.web.servlet.AbstractShiroFilter#doFilterInternal createSubject AbstractShiroFilter#createSubject== 创建subject updateSessionLastAccessTime == 更新session最后访问时间 executeChain AbstractShiroFilter#executeChain ==获取过滤链，执行过滤方法 12345protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain)&#123; FilterChain chain = getExecutionChain(request, response, origChain); //获取过滤链：如FormAuthenticationFilter chain.doFilter(request, response);&#125; 12eg:FormAuthenticationFilter#doFilter===父类OncePerRequestFilter的doFilter OncePerRequestFilter#doFilter---doFilterInternal---AdviceFilter#doFilterInternal 12345678910111213141516171819AdviceFilter#doFilterInternal preHandle AdviceFilter#preHandle true LogoutFilter#preHandle false PathMatchingFilter#preHandle--isFilterChainContinued--onPreHandle AnonymousFilter#onPreHandle true NoSessionCreationFilter#onPreHandle true PathMatchingFilter#onPreHandle true AccessControlFilter#onPreHandle isAccessAllowed onAccessDenied executeChain ==其他过滤器执行 postHandle ==没有实现类 cleanup AdviceFilter#cleanup ==没实现 AuthenticatingFilter#cleanup onAccessDenied FormAuthenticationFilter#onAccessDenied BasicHttpAuthenticationFilter#onAccessDenied filter 执行顺序 https://www.cnblogs.com/ljdblog/p/6237683.html https://www.cnblogs.com/q95265/p/6928081.html filter执行—doFilter1234567891011121314151617181920public final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)&#123; String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName(); if ( request.getAttribute(alreadyFilteredAttributeName) != null ) &#123; //已经执行过该过滤器 filterChain.doFilter(request, response); &#125; else if ( !isEnabled(request, response) ||shouldNotFilter(request) ) &#123; //该过滤器不适合该请求 filterChain.doFilter(request, response); &#125; else &#123; request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE); try &#123; //执行该过滤器 doFilterInternal(request, response, filterChain); &#125; finally &#123; // Once the request has finished, we're done and we don't // need to mark as 'already filtered' any more. request.removeAttribute(alreadyFilteredAttributeName); &#125; &#125;&#125; shiro通过一系列url匹配符配置URL应用上的Filter，然后在Filter中完成相应的任务。核心逻辑-doFilterInternal OncePerRequestFilter：保证每个filter都执行一次 ​ –AbstractShiroFilter ​ –AdviceFilter AbstractShiroFilterspringfactorybean返回的bean核心就是这个类，封装为shirofilter 构造方法 12345678910public void init() throws Exception &#123; WebEnvironment env = WebUtils.getRequiredWebEnvironment(getServletContext()); //SecurityManager setSecurityManager(env.getWebSecurityManager()); //FilterChainResolver FilterChainResolver resolver = env.getFilterChainResolver(); if (resolver != null) &#123; setFilterChainResolver(resolver); &#125;&#125; 12345678910111213protected void doFilterInternal(ServletRequest servletRequest, ServletResponse servletResponse, final FilterChain chain) &#123; final ServletRequest request = prepareServletRequest(servletRequest, servletResponse, chain); final ServletResponse response = prepareServletResponse(request, servletResponse, chain); final Subject subject = createSubject(request, response); //noinspection unchecked subject.execute(new Callable() &#123; public Object call() throws Exception &#123; updateSessionLastAccessTime(request, response); executeChain(request, response, chain); return null; &#125; &#125;);&#125; createSubject每次调用都会创建subject executeChain123456protected void executeChain(ServletRequest request, ServletResponse response, FilterChain origChain) &#123; //获取当前url匹配的过滤器链 FilterChain chain = getExecutionChain(request, response, origChain); //执行过滤器链中过滤器 chain.doFilter(request, response);&#125; 123456789101112131415161718protected FilterChain getExecutionChain(ServletRequest request, ServletResponse response, FilterChain origChain) &#123; FilterChain chain = origChain; //获取过滤器链解析器，即创建的PathMatchingFilterChainResolver对象 FilterChainResolver resolver = getFilterChainResolver(); if (resolver == null) &#123; log.debug("No FilterChainResolver configured. Returning original FilterChain."); return origChain; &#125; // 调用其getChain方法，根据URL匹配相应的过滤器链 FilterChain resolved = resolver.getChain(request, response, origChain); if (resolved != null) &#123; log.trace("Resolved a configured FilterChain for the current request."); chain = resolved; &#125; else &#123; log.trace("No FilterChain configured for the current request. Using the default."); &#125; return chain;&#125; AdviceFilter这个类很多方法实现了spring中的aop特点，prehandle前置通知，posthandle后置通知，异常不执行，afterCompletion （最终通知，一定会执行），可以根据需求覆写这几个方法 123456789101112131415161718public void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain)&#123; Exception exception = null; try &#123; //前置通知，判断该过滤链是否支持该请求 boolean continueChain = preHandle(request, response); if (continueChain) &#123; //执行过滤器链 executeChain(request, response, chain); &#125; //后置通知 postHandle(request, response); &#125; catch (Exception e) &#123; exception = e; &#125; finally &#123; //最终通知 cleanup(request, response, exception); &#125;&#125; eg: preHandle 根据配置，访问URL:”/authenticated.jsp”时，会匹配上authc(FormAuthenticationFilter) FormAuthenticationFilter继承自PathMatchingFilter，所以返回true ，而logoutfilter会返回false,啥也没有返回给页面，页面显示空白 12345678910111213protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123; for (String path : this.appliedPaths.keySet()) &#123;// If the path does match, then pass on to the subclass implementation for specific checks//(first match 'wins'): if (pathsMatch(path, request)) &#123;log.trace("Current requestURI matches pattern '&#123;&#125;'. Determining filter chain execution...", path); Object config = this.appliedPaths.get(path); return isFilterChainContinued(request, response, path, config); &#125; &#125; //no path matched, allow the request to go through: return true;&#125; 1234private boolean isFilterChainContinued(ServletRequest request, ServletResponse response, String path, Object pathConfig) throws Exception &#123; return onPreHandle(request, response, pathConfig);&#125; org.apache.shiro.web.filter.AccessControlFilter#onPreHandle 1234public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123; //如果isAccessAllowed方法返回false，则会执行onAccessDenied方法 return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);&#125; isAccessAllowed：表示是否允许访问；mappedValue就是[urls]配置中拦截器参数部分，如果允许访问返回true，否则false； onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；如果返回false表示该拦截器实例已经处理了，将直接返回即可 org.apache.shiro.web.filter.authc.AuthenticatingFilter#isAccessAllowed 1234protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123; return super.isAccessAllowed(request, response, mappedValue) || (!isLoginRequest(request, response) &amp;&amp; isPermissive(mappedValue));&#125; org.apache.shiro.web.filter.authc.AuthenticationFilter#isAccessAllowed 1234protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123; Subject subject = getSubject(request, response); return subject.isAuthenticated();&#125; 1234567891011121314151617181920212223242526protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123; //是否为登陆请求 if (isLoginRequest(request, response)) &#123; //是否是POST请求 if (isLoginSubmission(request, response)) &#123; if (log.isTraceEnabled()) &#123; log.trace("Login submission detected. Attempting to execute login."); &#125; return executeLogin(request, response); &#125; else &#123; if (log.isTraceEnabled()) &#123; log.trace("Login page view."); &#125; //allow them to see the login page ;) return true; &#125; &#125; else &#123; if (log.isTraceEnabled()) &#123; log.trace("Attempting to access a path which requires authentication. Forwarding to the " + "Authentication url [" + getLoginUrl() + "]"); &#125; //执行跳转到登陆界面login.jsp saveRequestAndRedirectToLogin(request, response); return false; &#125;&#125; login.jsp也会被拦截，执行到这里然后访问login.jsp, 再然后post请求这个url,就会执行executeLogin org.apache.shiro.web.filter.authc.AuthenticatingFilter#executeLogin 1234567891011121314151617protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception &#123; AuthenticationToken token = createToken(request, response); if (token == null) &#123; String msg = "createToken method implementation returned null. A valid non-null AuthenticationToken " + "must be created in order to execute a login attempt."; throw new IllegalStateException(msg); &#125; try &#123; Subject subject = getSubject(request, response); subject.login(token); //重定向到上次访问的url,过滤链不再执行 return onLoginSuccess(token, subject, request, response); &#125; catch (AuthenticationException e) &#123; //过滤链继续执行，返回到登陆界面 return onLoginFailure(token, e, request, response); &#125;&#125; 认证流程1234567891011121314151617181920212223242526272829303132333435363738public void login(AuthenticationToken token) throws AuthenticationException &#123; clearRunAsIdentitiesInternal(); //securityManager 登录 Subject subject = securityManager.login(this, token); PrincipalCollection principals; String host = null; if (subject instanceof DelegatingSubject) &#123; DelegatingSubject delegating = (DelegatingSubject) subject; //we have to do this in case there are assumed identities - we don't want to lose the 'real' principals: principals = delegating.principals; host = delegating.host; &#125; else &#123; principals = subject.getPrincipals(); &#125; if (principals == null || principals.isEmpty()) &#123; String msg = "Principals returned from securityManager.login( token ) returned a null or " + "empty value. This value must be non null and populated with one or more elements."; throw new IllegalStateException(msg); &#125; this.principals = principals; this.authenticated = true; if (token instanceof HostAuthenticationToken) &#123; host = ((HostAuthenticationToken) token).getHost(); &#125; if (host != null) &#123; this.host = host; &#125; Session session = subject.getSession(false); if (session != null) &#123; this.session = decorate(session); &#125; else &#123; this.session = null; &#125;&#125; 1234567891011121314151617181920212223public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException &#123; AuthenticationInfo info; try &#123; //关键逻辑 info = authenticate(token); &#125; catch (AuthenticationException ae) &#123; try &#123; onFailedLogin(token, ae, subject); &#125; catch (Exception e) &#123; if (log.isInfoEnabled()) &#123; log.info("onFailedLogin method threw an " + "exception. Logging and propagating original AuthenticationException.", e); &#125; &#125; throw ae; //propagate &#125; //认证成功，重新创建subject Subject loggedIn = createSubject(token, info, subject); //处理rememberme逻辑 onSuccessfulLogin(token, info, loggedIn); return loggedIn;&#125; org.apache.shiro.mgt.AuthenticatingSecurityManager#authenticate 123public AuthenticationInfo authenticate(AuthenticationToken token) &#123; return this.authenticator.authenticate(token);&#125; org.apache.shiro.authc.AbstractAuthenticator#authenticate ​ org.apache.shiro.authc.pam.ModularRealmAuthenticator#authenticate 模板方法模式 123456789protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException &#123; assertRealmsConfigured(); Collection&lt;Realm&gt; realms = getRealms(); if (realms.size() == 1) &#123; return doSingleRealmAuthentication(realms.iterator().next(), authenticationToken); &#125; else &#123; return doMultiRealmAuthentication(realms, authenticationToken); &#125; &#125; 1234567891011121314151617protected AuthenticationInfo doMultiRealmAuthentication(Collection&lt;Realm&gt; realms, AuthenticationToken token) &#123; //多realm下的认证策略默认实现为AtLeastOneSuccessfulStrategy AuthenticationStrategy strategy = getAuthenticationStrategy(); AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token); for (Realm realm : realms) &#123; aggregate = strategy.beforeAttempt(realm, token, aggregate); if (realm.supports(token)) &#123; //关键实现方法 AuthenticationInfo info = realm.getAuthenticationInfo(token); aggregate = strategy.afterAttempt(realm, token, info, aggregate, t); &#125; else &#123; log.debug("Realm [&#123;&#125;] does not support token &#123;&#125;. Skipping realm.", realm, token); &#125; &#125; aggregate = strategy.afterAllAttempts(token, aggregate); return aggregate;&#125; 1234567891011121314public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; AuthenticationInfo info = getCachedAuthenticationInfo(token); if (info == null) &#123; //覆盖实现核心认证信息 info = doGetAuthenticationInfo(token); if (token != null &amp;&amp; info != null) &#123; cacheAuthenticationInfoIfPossible(token, info); &#125; &#125; if (info != null) &#123; assertCredentialsMatch(token, info); &#125; return info;&#125; eg:自定义realmA实现AuthenticatingRealm 12345678910111213141516171819202122232425public class ShiroRealmA extends AuthenticatingRealm &#123; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; System.out.println("===&gt;ShiroRealmA&lt;=====" + JSON.toJSONString(token)); /** * 1. 吧AuthenticationToken转为usernamepasswordtoken * 2. 获取用户名与密码 * 3. 调用数据库的方法 * 4. 根据数据库用户情况抛出异常或构建AuthenticationInfo */ UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) token; String username = usernamePasswordToken.getUsername(); // 数据库获取的密码，，前端加密 密码加密 //盐值一般是唯一值，可以是用户名 ByteSource salt = ByteSource.Util.bytes(username); Object credentials = "123"; Object credentialsMD5 = new SimpleHash("MD5", credentials, salt, 2); if ("zs".equals(username)) &#123; return new SimpleAuthenticationInfo(username,credentialsMD5, salt, this.getName()); &#125; else &#123; throw new AuthenticationException(); &#125; &#125;&#125; 授权流程perms(PermissionsAuthorizationFilter.class) ：url是否有权限 roles(RolesAuthorizationFilter.class), ：url是否有该角色 12345678910111213141516171819public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException &#123; Subject subject = getSubject(request, response); //访问需要的权限 String[] perms = (String[]) mappedValue; //subject判断是否有权限 boolean isPermitted = true; if (perms != null &amp;&amp; perms.length &gt; 0) &#123; if (perms.length == 1) &#123; if (!subject.isPermitted(perms[0])) &#123; isPermitted = false; &#125; &#125; else &#123; if (!subject.isPermittedAll(perms)) &#123; isPermitted = false; &#125; &#125; &#125; return isPermitted;&#125; ModularRealmAuthorizer.isPermitted 1234567891011public boolean isPermitted(PrincipalCollection principals, String permission) &#123; assertRealmsConfigured(); for (Realm realm : getRealms()) &#123; if (!(realm instanceof Authorizer)) continue; // 调用Realm的isPermitted方法 if (((Authorizer) realm).isPermitted(principals, permission)) &#123; return true; &#125; &#125; return false;&#125; 123public boolean isPermitted(String permission) &#123; return hasPrincipals() &amp;&amp; securityManager.isPermitted(getPrincipals(), permission);&#125; 12public boolean isPermitted(PrincipalCollection principals, String permissionString) &#123; return this.authorizer.isPermitted(principals, permissionString); 123456789public boolean isPermitted(PrincipalCollection principals, String permission) &#123; Permission p = getPermissionResolver().resolvePermission(permission); return isPermitted(principals, p); &#125; public boolean isPermitted(PrincipalCollection principals, Permission permission) &#123; AuthorizationInfo info = getAuthorizationInfo(principals); return isPermitted(permission, info); &#125; 1234567891011121314151617181920protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) &#123; AuthorizationInfo info = null; //缓存中获取授权信息 Cache&lt;Object, AuthorizationInfo&gt; cache = getAvailableAuthorizationCache(); if (cache != null) &#123; Object key = getAuthorizationCacheKey(principals); info = cache.get(key); &#125; if (info == null) &#123; // 继承覆盖实现获取授权信息 info = doGetAuthorizationInfo(principals); if (info != null &amp;&amp; cache != null) &#123; Object key = getAuthorizationCacheKey(principals); cache.put(key, info); &#125; &#125; return info;&#125; ModularRealmAuthorizer.isPermittedAll AuthorizationFilter#onAccessDenied 12345678910111213141516protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException &#123; Subject subject = getSubject(request, response); //未登陆，跳转到登陆界面 if (subject.getPrincipal() == null) &#123; saveRequestAndRedirectToLogin(request, response); &#125; else &#123; //登陆未授权、返回未授权界面或者401状态码 String unauthorizedUrl = getUnauthorizedUrl(); if (StringUtils.hasText(unauthorizedUrl)) &#123; WebUtils.issueRedirect(request, response, unauthorizedUrl); &#125; else &#123; WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED); &#125; &#125; return false;&#125; FormAuthenticationFilterOnceperrequestfilter#doFilter adviceFilter#doFilterInternal AdviceFilter#preHandle true AuthenticatingFilter#cleanup FormAuthenticationFilter#onAccessDenied 1234567891011121314protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123; //是否为登陆请求 if (isLoginRequest(request, response)) &#123; //是否是post请求 if (isLoginSubmission(request, response)) &#123; return executeLogin(request, response); &#125; else &#123; return true; &#125; &#125; else &#123; saveRequestAndRedirectToLogin(request, response); return false; &#125;&#125; org.apache.shiro.web.filter.authc.AuthenticatingFilter#executeLogin 12345678910protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception &#123; AuthenticationToken token = createToken(request, response); try &#123; Subject subject = getSubject(request, response); subject.login(token); return onLoginSuccess(token, subject, request, response); &#125; catch (AuthenticationException e) &#123; return onLoginFailure(token, e, request, response); &#125;&#125; go to 认证流程 PermissionsAuthorizationFilterOnceperrequestfilter#doFilter adviceFilter#doFilterInternal PathMatchingFilter#preHandle AccessControlFilter#onPreHandle go to 授权流程 ​ PermissionsAuthorizationFilter#isAccessAllowed ​ AuthorizationFilter#onAccessDenied RolesAuthorizationFilter与PermissionsAuthorizationFilter类似 UserFilter是登录页面或者必须登录后获得principalCollection，才能通过 12345678protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123; if (isLoginRequest(request, response)) &#123; return true; &#125; else &#123; Subject subject = getSubject(request, response); return subject.getPrincipal() != null; &#125; &#125; 1234protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123; saveRequestAndRedirectToLogin(request, response); return false; &#125; 参考文献 https://blog.csdn.net/xtayfjpk/article/details/53729135 http://suichangkele.iteye.com/blog/2277023]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>filter</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet/filter/listener/interceptor]]></title>
    <url>%2F2018%2F10%2F25%2Fservlet-filter-listener-interceptor%2F</url>
    <content type="text"><![CDATA[概念servlet 是一种运行再服务端的java应用程序，具有独立与平台和协议的特性，并且可以动态的生成web页面，它工作在客户端请求和服务端响应的中间层 创建并返回给客户端完整的html页面 filter 过滤器，是一个可以复用的代码片段、可以用来转换http请求、响应和头信息。不像servlet,它不能产生一个请求或响应、只能修改某一资源的请求、或者修改某一资源的响应 能够在一个请求到达servlet之前预处理用户请求，也可以在离开servlet时处理http响应 url传来后，检查之后，可保持原来的流程继续向下执行，被下一个filter处理,servlet接收后，不会向下传递。 listenter 监听器、通过listener可以监听web服务器中的某一个执行动作、并根据其要求做出相应的响应。再application\session\request三个对象创建消亡或者添加修改属性时自动执行代码的功能组件 servlet、filter时针对url之类的，而listener是针对对象的操作，在这些对象变化的时候做一些操作 interceptor 面向切面编程中，就是再你的servcie或者一个方法前后，比如动态代理就是拦截器的简单实现，只能对controller请求进行拦截 类似与框架带的filter 不在web.xml中配置，框架配置文件中 由action自己指定用哪个interceptor来接受处理，并且访问action上下文，过滤器可以对几乎所有的请求起作用 拦截器是基于java 反射的，过滤器是基于函数回调的 拦截器不依赖与serlvet容器，过滤器依赖于servlet容器 生命周期servlet它被装入web服务器的内存，并在web服务器终止或者重新装入servlet时结束。servlet一但装入web服务器，一般就不会在web服务器内存中删除、直到web服务器关闭或重新结束。 装入：启动服务器时加载servlet的实例 初始化：web服务器启动时或者接受到请求时，初始化工作init()方法负责执行完成 调用：从第一次到以后的多次访问，都只调用doget（）或dopost方法 销毁：停止服务器时调用destory（）方法，销毁实例 filterFilter接口方法有init().doFilter(),dodestory() 启动服务器时加载过滤器实例，并调用init()方法来初始化实例 每一次请求时都只调用方法doFilter()进行处理，调用下一过滤器chain.doFilter 停止服务器时调用destory()方法，销毁实例 listenerinterceptor struts 的拦截器在加载xml后，初始化相应拦截器，当action请求来时调用intercept方法，服务器停止销毁interceptor prehandle(action执行之前)，posthandle(方法执行之后，不一定会执行)，aftercompletion（最终执行） 顺序web.xml的加载顺序context-param-&gt;listener-&gt;filter-&gt;servlet 执行顺序： filter1————————–web.xml中的配置顺序 ​ -&gt;interceptor1(prehandle)–框架中的拦截器 ​ -&gt;servlet1 ​ -&gt;interceptor1(posthandle,aftercompletion) -&gt;filter1 应用举例filter在过滤器中修改字符编码，在过滤器中修改request的参数（链路跟踪） interceptor日志，在方法调用前后打印出字符串 参考文献https://blog.csdn.net/sundenskyqq/article/details/8549932 https://blog.csdn.net/tanga842428/article/details/52175683 https://blog.csdn.net/zxd1435513775/article/details/80556034 https://www.cnblogs.com/jzb-blog/p/6717349.html]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>listener</tag>
        <tag>filter</tag>
        <tag>interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能监控]]></title>
    <url>%2F2018%2F10%2F25%2F%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[为什么要性能监控了解系统的运行情况，有计划的改善项目的运行，提供系统的性能，保证系统稳定性等 监控哪些系统层面last min avg max cpu cpu jumps context switchs per second：线程的切换，切换过多会导致cpu忙于切换，影响吞吐率 interrupts per second cpu load cpu使用队列的长度的统计信息 processor load (1 min average per core) processor load (5 min average per core) processor load (15 min average per core) cpu utilization 利用率 cpu idle time cpu user time cpu system time cpu iowait time cpu nice time cpu interrupt time cpu steal time memory内存 memory usage avaulable memory 磁盘 disk space usage total disk space in free disk space on disk space /opt network网络 network traffic on eth0 incoming network traffic on eth0 outgoing network traffic on eth0 软件层面数据库tomcatjvm应用方面应用类型 IO相关：Io相关的应用通常用来处理大量数据，需要大量内存和存储，频繁IO操作读写操作，而对cpu的要求比较少，大部分时候cpu再等待磁盘eg:数据库服务器、文件服务器 CPU相关：CPU相关大的应用需要大量cpu资源，比如高并发的web/mail服务器、图像、视频处理、科学计算等 方法论压测jmeter线程就是并发数、吞吐量就是QPS 监控工具 工具 简单介绍 top 查看进程活动状态以及一些系统状况 vmstat 查看系统状态、硬件和系统信息等 iostat 查看cpu负载、硬盘状态 sar 综合工具、查看系统状态 mpstat 查看多处理器状况 netstat 查看网络状况 iptraf 实时网络状况检测 tcpdump 抓取网络数据包、详细分析 mpstat 查看多处理器状况 tcptrace 数据包分析工具 netperf 网络带宽工具 dstat 综合工具、综合了vmstat\iostat\ifstat\netstat等 参考文献https://blog.csdn.net/tianlesoftware/article/details/6198780 https://blog.csdn.net/marising/article/details/5182771]]></content>
      <categories>
        <category>性能监控</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存初始]]></title>
    <url>%2F2018%2F10%2F19%2F%E7%BC%93%E5%AD%98%E5%88%9D%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[什么是缓存临时存放数据（读多写少）的地方，介于外部请求和真实数据之间； 什么情况下要缓存数据的类型，业务的特点：读多写少，在正常工作的前提下响应时间尽可能短。 缓存的类型根据缓存位置的不同的不同分为硬件缓存，客户端缓存，服务端缓存 硬件缓存：硬盘缓存和cpu缓存，提高硬盘和cpu之间的暂存器 客户端缓存：会把用户之前浏览的东西存在本地，在下次访问是，如果本地的缓存有请求的内容，就直接取，不再向服务器请求 服务端缓存：如果每次客户端请求都要链接一次数据库，当用户请求多的时候，负载过大，这时把一些经常请求的数据存放在内存中，当有请求时直接返回，不经过数据库，这样就可以减轻数据库负担 进程缓存or分布式缓存or多级缓存 失效策略（缓存算法）如果缓存满了，而当前请求又没有命中缓存，那么会按照一种策略，把缓存中的某一种旧资源剔除，而把新的资源加入缓存，这些决定应该剔除哪个旧资源的策略就是失效策略 成本：如果缓存对象有不同的存储成本，应该把那些难以获得的对象保存下来 容量：如果缓存对象有不同的大小，应该把那些大的缓存清除，让更多的小缓存对象进来 时间：一些缓存设定有过期时间，应该在到时间之后将他们失效 常见失效策略simple time-based 通过绝对的时间周期删除缓存对象，对于新增的对象，保存设定的时间后，将其失效，原理简单，效果不好 extended time-based expiration 通过相对时间去失效缓存对象，对于新增的缓存对象，会保存特定的时间，比如每5分钟，每天12点 sliding time-based expiration 计算最后访问这个缓存的时间算起，最后一次访问对象1小时后 FIFO:First in First Out 判断被存储的时间，最早缓存数据优先被剔除 LRU:Least Recently Used 最近最少，使用一个链表来保存。新数据插入链表头部，命中后，将数据移到链表头部，满了后，尾部数据丢弃,有个热点数据有段时间没访问，会导致这个热点数据淘汰 LFU:Least Frequently Used 最不经常使用原则，在一段时间内，数据命中 次数最少，优先被剔除，利用额外的空间记录每个数据的使用频率，选出频率最低的进行淘汰 对比与分析失效策略出发点有两个，基于时间（FIFO）、基于命中次数(LRU,MRU,2Q),最常使用的时FIFO,LRU,LFU 不同的访问模型导致命中率变化较大，实际应用中需要根据业务的需求和对数据的访问请求进行选择，并不是命中率越高越好，考虑点包括：命中率，复杂度？，代价（时间复杂度、空间复杂度）等，如何衡量。。。 更新缓存的方法定时失效mq通知缓存问题缓存穿透查询一个不存在的数据，首先，缓存命不中，数据库查不到，这样的请求每次都会请求数据库，流量大的时候，可能数据库就挂了。 解决办法： 过滤器：布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截 设定指定值：如果一个查询返回的数据为空，依然要把空结果进行缓存，缓存的值设定位一个指定值，同时设置它的过期时间很短，最长不超过5分钟 缓存雪崩在某一时刻，大量缓存同时失效，请求全部到数据库，导致数据压力过大 解决办法： 加锁或者队列的方式保证缓存的单线程来写，把失效时间分开 将数据失效时间均匀分布在时间轴上，在原有的失效时间基础上增加一个随机值 缓存并发如果一个缓存如果失效，可能出现多个进程同时查询DB， 解决办法： 对缓存查询加锁，如果key不存在，就加锁，然后查DB写入缓存，然后解锁 大厂经验爱奇艺 数据同步加Redis：依赖于Redis，一旦redis挂了，整个缓存系统不可用 javamap加redis：进程内缓存作为一级缓存，redis作为二级缓存，进程内缓存无法做到实时更新，当不需要淘汰机制，可以使用map，问题： 锁竞争严重 不支持过期时间 不支持自动刷新 guava cache加redis：设置写后刷新时间，进行刷新，解决了一直不更新的问题，但是依然没有解决实时刷新 外部缓存异步刷新：利用redis作为消息队列通知机制，通知其他应用进行刷新 参考文献 https://juejin.im/post/5b7593496fb9a009b62904fa#comment https://juejin.im/post/5b849878e51d4538c77a974a http://twei.site/2017/07/15/%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E4%BA%8B-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98/]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis代码生成工具]]></title>
    <url>%2F2018%2F10%2F19%2Fmybatis%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[使用方式之一====MAVEN XML配置参数说明 其他注意事项 使用方式之一====MAVENpom12345678910111213141516171819202122232425262728293031&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt;&lt;/dependency&gt;&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; generatorConfig.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;classPathEntry location="C:/repository/mysql/mysql-connector-java/5.1.26/mysql-connector-java-5.1.26.jar"/&gt;&lt;context id="sqlserverTables" targetRuntime="MyBatis3"&gt; &lt;!-- 生成的pojo，将implements Serializable --&gt; &lt;plugin type="org.mybatis.generator.plugins.SerializablePlugin"&gt;&lt;/plugin&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库链接URL、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://数据库地址" userId="daojia_root" password="aaa111"&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer true，把JDBC DECIMAL和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成model模型，对应的包路径，以及文件存放路径(targetProject)，targetProject可以指定具体的路径,如./src/main/java， 也可以使用“MAVEN”来自动生成，这样生成的代码会在target/generatord-source目录下 --&gt; &lt;!--&lt;javaModelGenerator targetPackage="com.joey.mybaties.test.pojo" targetProject="MAVEN"&gt; --&gt; &lt;javaModelGenerator targetPackage="entity" targetProject="MAVEN"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!--对应的mapper.xml文件 --&gt; &lt;sqlMapGenerator targetPackage="mappers" targetProject="MAVEN"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 对应的Mapper接口类文件 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="dao" targetProject="MAVEN"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 列出要生成代码的所有表，这里配置的是不生成Example文件 --&gt; &lt;table tableName="t_app_order" domainObjectName="Order"&gt; &lt;/table&gt;&lt;/context&gt; table必填 tableName ：表名 可选 schema catalog alias domainObjectName ：生成对象的名称 mapperName ：生成的dao和xml文件的名称：默认是加后缀mapper sqlProviderName ：生成实体的的sqlProvider，默认是加后缀SqlProvider enableInsert ：insert方法，默认true enableSelectByPrimaryKey :查询根据主键，默认true enableSelectByExample :根据example查询，默认true enableUpdateByPrimaryKey :根据主键更新 enableDeleteByPrimaryKey ：根据主键删除,不推荐—–改为false enableDeleteByExample ：根据example删除 ，不推荐—改为false enableCountByExample ：根据example计数，true enableUpdateByExample :根据example更新 selectByPrimaryKeyQueryId selectByExampleQueryId modelType escapeWildcards delimitIdentifiers delimitAllColumns 其他注意事项example 使用 方法 说明 example.setOrderByClause(“字段名 ASC”); 添加升序排列条件，DESC为降序 example.setDistinct(false） 去除重复，boolean型，true为选择不重复的记录。 criteria.andXxxIsNul 添加字段xxx为null的条件 criteria.andXxxIsNotNull 添加字段xxx不为null的条件 criteria.andXxxEqualTo(value) 添加xxx字段等于value条件 criteria.andXxxNotEqualTo(value) 添加xxx字段不等于value条件 criteria.andXxxGreaterThan(value) 添加xxx字段大于value条件 criteria.andXxxGreaterThanOrEqualTo(value) 添加xxx字段大于等于value条件 criteria.andXxxLessThan(value) 添加xxx字段小于value条件 criteria.andXxxLessThanOrEqualTo(value) 添加xxx字段小于等于value条件 criteria.andXxxIn(List&lt;？&gt;) 添加xxx字段值在List&lt;？&gt;条件 criteria.andXxxNotIn(List&lt;？&gt;) 添加xxx字段值不在List&lt;？&gt;条件 criteria.andXxxLike(“%”+value+”%”) 添加xxx字段值为value的模糊查询条件 criteria.andXxxNotLike(“%”+value+”%”) 添加xxx字段值不为value的模糊查询条件 criteria.andXxxBetween(value1,value2) 添加xxx字段值在value1和value2之间条件 criteria.andXxxNotBetween(value1,value2) 添加xxx字段值不在value1和value2之间条件 sqlprovider使用在类中写sql，mapper接口上标注方法，四不像 参考文献 http://www.mybatis.org/generator/configreference/table.html http://www.cnblogs.com/wangkeai/p/6934683.html]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>代码生成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位操作符]]></title>
    <url>%2F2018%2F10%2F15%2F%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[基本数据类型，进制以及常用的用法 进制 二进制位 简称“位”，一个二进制包含的信息称为一比特（bit）.每一个bit可以代表0或1的数位信号，是电脑记忆体中最小的单位； 字节：bye:是计算机可寻址的最小单位，每个字节有8个二进制位。 word 字，有2byte组成， 十进制：10 八进制：012 十六进制：0x0a 二进制：1010 CPU主要有32位，64位，32位cpu能够寻址的范围是4GB,,通常一个cpu指令是4byte,执行一次就读取32bit内容 基本数据类型c.c++在不同的操作系统平台，给基本类型变量分配的字节是不一样的。java是跨平台语言，JVM包装后的基本数据字节长度是一样的 12345678byte:1字节short:2字节int:4字节long:8字节float:4字节double:8字节char:2字节boolean:在存储的时候不使用字节，仅仅使用1位来存储，范围为0或1 int long等整数类型最高位是符号位，正数是0 ，负数是1 原码将一个数字转换为二进制就是这个数字的原码 反码正数的反码是原码 负数的反码是在原码的基础上，符号位不变，其他位都取反 -3 原码 1000 0000 0000 0011 -3 反码 1111 1111 1111 1100 补码正数的补码是原码，也就是反码 负数的补码的基础上加1 -3 的补码: 1111 1111 1111 1101 补码是因为计算机在进行数值计算的时候，是通过补码来表示每个数值，好处是减法的计算方式与加法一样 1234565 - 3 = 5 + (-3) =2 00000000 00000000 00000000 00000101+ 11111111 11111111 11111111 11111101 =================================== 100000000 00000000 00000000 00000010 = 2 //最高位溢出 double float位操作符与 &amp;两个位 都为1 结果是1 应用： 清零：与一个各位都是0的数值相与，结果是0 去一个数中的指定位：取4位，，，，A &amp; 0000 1111= 0000 AAAA,得到A的最后四位 或 |只要有一位是1，结果就是1 应用： 置1：将指定位置置为1 非 ~对操作数的每一位进行操作，1变0，0变1 异或 ^两个数 数值相同则为0，数值不同则为1 应用： 简单的数值加密：与某一个数值异或，再与该数值异或，变为原来的数值 翻转特定为：X = 1010 1110将低4位翻转，X^0000 1111 = 1010 0001 右移&gt;&gt;符号位不变，整体向右方向移动n位，高位空出来的位数值为0 a&gt;&gt;b = a/(2^b) 左移&lt;&lt;符号位不变，低位空出来的位补数值0 a&lt;&lt;b = a*(2^b) 使用其他进制转二进制字符串在java里Integer、Long这两个类里都以下三个方法： //将i转换成二进制 toBinaryString(long i); toBinaryString(int i); //将i转换成十六进制 toHexString(long i); toHexString(int i); //将i转换成八进制 toOctalString(long i); toOctalString(int i); 二进制转其他进制Integer、Long两个类里都将字符串转换成各种不同进制的方法： parseInt(String s, int radix); parseLong(String s, int radix); 参考文献 https://blog.csdn.net/briblue/article/details/70296326 https://blog.csdn.net/xwu_09/article/details/78285785 https://blog.csdn.net/luoweifu/article/details/8180509]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>位操作符</tag>
        <tag>基本数据类型</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson]]></title>
    <url>%2F2018%2F09%2F29%2Ffastjson%2F</url>
    <content type="text"><![CDATA[json基本格式，以及fastjson基本用法，包括序列化与反序列化 JSON 是什么是一种文本方式展示结构化数据的方式 结构和类型对象用{}，内部是“key”:”value” 数组用[]表示，不同值用逗号分开 优缺点优点：平台无关性 缺点：性能一般，缺少schema API序列化基本序列化12User u = new User();JSON.toJSONString(u); 使用WriteClassName特性序列化的时候写入类型信息，反序列化的时候，可以根据类型自动识别 123456789Color color = Color.RED;String text = JSON.toJSONString(color, SerializerFeature.WriteClassName);System.out.println(text);&#123;"@type":"java.awt.Color","r":255,"g":0,"b":0,"alpha":255&#125;Color color = (Color) JSON.parse(text); 循环引用123456789A a = new A();B b = new B();a.setB(b);b.setA(a);System.out.println(JSON.toJSONString(a));//&#123;"b":&#123;"a":&#123;"$ref":".."&#125;&#125;&#125; 使用toJSON会栈溢出A a1 = JSON.parseObject(JSON.toJSONString(a), A.class);System.out.println(a1 == a1.getB().getA());//true 使用@JSONField Annotation1234567@JSONField(name ="hah")private String name;A a = new A();a.setName("xxx");System.out.println(JSON.toJSONString(a));//&#123;"hah":"xxx"&#125; 反序列化指定CLass信息反序列化1JSON.parseObject(s，User.class); 类型集合的反序列化1List&lt;User&gt; users = JSON.parseArray(s,User.class); 泛型集合的反序列化1Map&lt;String,User&gt; userMap = JSON.parseObject(s,new TypeReference&lt;Map&lt;String,User&gt;&gt;()&#123;&#125;); 参考文献http://zyjustin9.iteye.com/blog/2020533]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>fastjson</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal]]></title>
    <url>%2F2018%2F09%2F04%2FThreadLocal%2F</url>
    <content type="text"><![CDATA[treadlocal定义，使用，基本原理以及注意点 代办：未完整 定义Threadlocal提供了线程本地的变量，这些变量绑定于自己的线程，独立的进行初始化。使用上通常是private static 变量，并且关联一个有状态的变量，如user ID 或Transaction ID. 通常是保存 线程中的状态的变量 使用123456789101112131415161718public class ThreadId &#123; // Atomic integer containing the next thread ID to be assigned private static final AtomicInteger nextId = new AtomicInteger(0); // Thread local variable containing each thread's ID private static final ThreadLocal&lt;Integer&gt; threadId = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return nextId.getAndIncrement(); &#125; &#125;; // Returns the current thread's unique ID, assigning it if necessary public static int get() &#123; return threadId.get(); &#125;&#125; 只要这个线程活着，并且threadllocal实例可用，那么每一个线程保持一个引用与threadlocal中变量的拷贝， ThreadLocal() 无参构造器 withInitial(Supplier&lt;? extends S&gt;):ThreadLocal 1234567891011121314151617public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) &#123; return new SuppliedThreadLocal&lt;&gt;(supplier);&#125;static final class SuppliedThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123; private final Supplier&lt;? extends T&gt; supplier; SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123; this.supplier = Objects.requireNonNull(supplier); &#125; @Override protected T initialValue() &#123; return supplier.get(); &#125;&#125; get():T 1234567891011121314public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; //如果没有值，那么就返回初始化值 return setInitialValue();&#125; set(T):void 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; remove():void 12345public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125; 原理分析ThreadLocalMap每个线程都有一个threadlocalmap成员变量 threalLocalMap底层是一个散列表(数组链表) tail -f /opt/web/dianshangwuxian_order-server/logs/catalina.log.2018-09-12 tail -f /opt/web/dianshangwuxian_order-server/logs/order-server.log entryentry定位注意点参考文献http://www.jasongj.com/java/threadlocal/#comments https://segmentfault.com/a/1190000014738647]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>threadlocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2018%2F08%2F27%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[概述 CLass类以及获取方法 类加载器ClassLoader 反射创建运行的类、获取属性与构造方法、 反射应用：动态代理、AOP 概述反射就是在运行时动态的获取类的属性和方法并调用 CLass类以及获取方法Class类任何语言使用其编译器把程序代码编译(javac.exe)成Class文件,然后通过类加载器(java.exe)加载Class文件到内存(堆内存？)中，这个运行时类就是一个Class的实例，最后通过字节码执行引擎来对方法调用与字节码执行。 特点 每一个运行类只加载一次 有了Class类实例，可以进行以下操作 创建对应的运行类的对象 获取对应的运行类的完整结构 调用对应的运行时类的指定的结构 反射应用：动态代理 Class获取方法 调用类本身的.class属性 1Class clazz = Persion.class; 运行时类的对象获取 12Persion p = new Persion();Class clazz = p.getClass(); 通过Class的静态方法获取（反射的动态性） 123String className = "com.cwm.Persion";Class clazz = Class.forName(className);//执行初始化静态代码块 通过类加载器 123ClassLoader classLoader = this.getClass().getClassLoader();Class clazz = classLoader.loadClass(className);//类还没有链接 加载，链接、初始化 类加载器ClassLoaderClass类实例操作创建运行时类对象1clazz.newInstance(); 获取运行类完整结构属性 方法 构造器 内部类 父类 所在包 注解 异常 调用运行类指定结构反射应用：动态代理、AOP动态代理AOPInvoke深度解析 人吧 缺点 消耗系统资源，什么资源？ 反射调用方法会忽略权限检查，破坏封装性 参考文献 https://www.sczyh30.com/tags/Reflection/ https://blog.csdn.net/love_gaohz/article/details/79905444 https://juejin.im/post/598ea9116fb9a03c335a99a4 https://www.cnblogs.com/mengdd/archive/2013/01/26/2878124.html https://www.zhihu.com/question/24304289]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
        <tag>classloader</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-xml配置文件的解析流程]]></title>
    <url>%2F2018%2F08%2F21%2Fspring-xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[加载xml配置文件,将bean注册到Map中 obtainFreshBeanFactoryorg.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory 12345678protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; refreshBeanFactory(); ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (logger.isDebugEnabled()) &#123; logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory); &#125; return beanFactory;&#125; refreshBeanFactory org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory 12345678910protected final void refreshBeanFactory() &#123; DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); //加载xml配置文件，具体子ApplicationContext loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125;&#125; loadBeanDefinitions有不同的实现类 XmlWebApplicationContext默认的spring容器 org.springframework.web.context.support.XmlWebApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory) 12345678910111213protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory)&#123; // 创建XmlBeanDefinitionReader，用它来读取XML配置文件 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // 配置beanDefinitionReader的环境和属性等 beanDefinitionReader.setEnvironment(getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // 初始化beanDefinitionReader，子类可以实现这个方法，做一些个性化配置和初始化 initBeanDefinitionReader(beanDefinitionReader); // 开始load xml文件 loadBeanDefinitions(beanDefinitionReader);&#125; 12345678910protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) &#123; //读取web.xml中的contextConfigLocation元素，没有读默认 String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; for (String configLocation : configLocations) &#123; //reader读取xml文件 reader.loadBeanDefinitions(configLocation); &#125; &#125;&#125; 1234567891011121314151617181920212223242526public int loadBeanDefinitions(EncodedResource encodedResource) &#123; //将Resource对象添加到hashSet中 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( "Detected cyclic loading of " + encodedResource + " - check your import definitions!"); &#125; InputStream inputStream = encodedResource.getResource().getInputStream(); InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // 加载封装好的inputSource对象，读取XML配置文件 return doLoadBeanDefinitions(inputSource, encodedResource.getResource());&#125;finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125;&#125;&#125; 1234567protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) &#123; //将xml转为Document Document doc = doLoadDocument(inputSource, resource); //Document转换为BeanDefinition并注册到BeanDefinitionMap return registerBeanDefinitions(doc, resource);&#125; 1private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;(64); 创建一个转换器实例然后调用注册benaDefinitions 1234567public int registerBeanDefinitions(Document doc, Resource resource) &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); documentReader.setEnvironment(getEnvironment()); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 1234567891011121314151617181920protected void doRegisterBeanDefinitions(Element root) &#123; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; return; &#125; &#125; &#125; preProcessXml(root); //装换文档中的标签 parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;&#125; 1234567891011121314151617181920protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 12345public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123; String namespaceUri = getNamespaceURI(ele); NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; 各种方法的标签解析，如何选择的呢？ 12345678910111213NamespaceHandler SimplePropertyNamespaceHandler SimpleConstructorNamespaceHandler NamespaceHandlerSupport JeeNamespaceHandler AopNamespaceHandler ContextNamespaceHandler LangNamespaceHandler UtilNamespaceHandler MvcNamespaceHandler TaskNamespaceHandler CacheNamespaceHandler TxNamespaceHandler]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-bean的创建和初始化]]></title>
    <url>%2F2018%2F08%2F21%2Fspring-bean%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[反射创建bean以及初始化 12345678910111213141516171819202122232425protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; // I初始化conversionService类型转换bean，它可以服务于其他bean的类型转换 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; //// 初始化LoadTimeWeaverAware bean String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; // Stop using the temporary ClassLoader for type matching. //// 停止使用临时的ClassLoader， beanFactory.setTempClassLoader(null); // Allow for caching all bean definition metadata, not expecting further changes. beanFactory.freezeConfiguration(); // Instantiate all remaining (non-lazy-init) singletons. //创建和初始化非lazy-init的singleton beans beanFactory.preInstantiateSingletons();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public void preInstantiateSingletons() throws BeansException &#123; // Iterate over a copy to allow for init methods which in turn register new bean definitions. // While this may not be part of the regular factory bootstrap, it does otherwise work fine. // 获取XML配置文件解析时，解析到的所有beanname List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames); // 遍历所有没有标注lazy-init的singleton的beanname,创建bean for (String beanName : beanNames) &#123; //利用beanname获取BeanDefinition，在XML解析时会生成BeanDefinition对象， //将XML中的各属性添加到BeanDefinition的相关标志位中，比如abstractFlag，scope等 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 非abstract，非lazy-init的singleton bean才需要在容器初始化阶段创建 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; // 处理FactoryBean if (isFactoryBean(beanName)) &#123; // 获取FactoryBean实例，FactoryBean前面会加一个&amp;符号 final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123; @Override public Boolean run() &#123; return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(); &#125; &#125;, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; // 非Factorybean,直接调用getBean方法 if (isEagerInit) &#123; getBean(beanName); &#125; &#125; else &#123; getBean(beanName); &#125; &#125; &#125; // Trigger post-initialization callback for all applicable beans... // bean创建后，对SmartInitializingSingleton回调afterSingletonsInstantiated()方法 for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125; &#125;&#125; 123public Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false);&#125; doGetBean123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; //beanname转换，去掉FactoryBean的&amp;前缀，处理alias声明 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; // 判断singleton bean是否已经创建好了，创建好了则直接从内存取出。 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125;else &#123; // Fail if we're already creating this bean instance: // We're assumably within a circular reference. if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. //检查是否有beanname对应的BeanDefinition BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // 没有找到BeanDefinition，看看parent工厂中有没有，调用parent工厂的getBean // 获取原始的name，包含了FactoryBean前缀，&amp;符号 String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; // 找到了beanname对应的BeanDefinition，合并parent的BeanDefinition(XML中的parent属性) final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. // 处理dependsOn属性 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; // 遍历所有的dependOn bean，要先注册和创建依赖的bean for (String dependsOnBean : dependsOn) &#123; // check是否两个bean是循环依赖，spring不能出现bean的循环依赖 if (isDependent(beanName, dependsOnBean)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dependsOnBean + "'"); &#125; // 注册并创建依赖的bean registerDependentBean(dependsOnBean, beanName); getBean(dependsOnBean); &#125; &#125; // Create bean instance. // 处理scope属性 if (mbd.isSingleton()) &#123; // singleton, 必须保证线程安全情况下创建bean，保证单例 sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; // 反射创建bean实例 return createBean(beanName, mbd, args); &#125; &#125;); // 获取bean实例 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125;else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; // 创建前的回调 beforePrototypeCreation(beanName); // 反射创建bean实例 prototypeInstance = createBean(beanName, mbd, args); &#125;finally &#123; // 创建后的回调，清除inCreation的标志 afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125;else &#123; // 其他scope值 String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; &#125;&#125;&#125;// check 创建的bean是否是requiredType指明的类型。如果不是，先做转换，转换不成的话只能类型不匹配抛出异常了if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123; // 尝试将创建的bean转换为requiredType指明的类型 return getTypeConverter().convertIfNecessary(bean, requiredType); &#125;return (T) bean;&#125; 123456789101112131415161718protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)&#123; // Make sure bean class is actually resolved at this point. // 拷贝一个新的RootBeanDefinition供创建bean使用 resolveBeanClass(mbd, beanName); // Prepare method overrides. //处理bean中定义的覆盖方法，主要是xml:lookup-method或replace-method。 //标记override的方法为已经加载过的，避免不必要的参数检查开销 mbd.prepareMethodOverrides(); // 调用BeanPostProcessors bean后处理器，使得bean后处理器可以返回一个proxy bean， //从而代替我们要创建的bean。回调后处理器的postProcessBeforeInstantiation()方法，如果这个方法中返回了一个bean，也就是使用了proxy，则再回调postProcessAfterInitialization()方法。之后返回这个Proxy bean即可。 Object bean = resolveBeforeInstantiation(beanName, mbd); if (bean != null) &#123; return bean; &#125; // doCreateBean创建bean实例 Object beanInstance = doCreateBean(beanName, mbd, args); return beanInstance;&#125; doCreateBean1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123; // 创建bean实例，如果是singleton，先尝试从缓存中取，取不到则创建 BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; // 反射创建bean实例 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); // Allow post-processors to modify the merged bean definition. // 回调MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition，它可以修改bean属性 synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. // 曝光单例对象的引用，主要是为了解决单例间的循环依赖问题，以及依赖的bean比较复杂时的初始化性能问题 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references"); &#125; addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // 初始化bean Object exposedObject = bean; populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; // 单例曝光对象的处理 if (earlySingletonExposure) &#123; Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException; &#125; &#125; &#125; &#125; // Register bean as disposable. // 注册bean为可销毁的bean，bean销毁时，会回调destroy-method registerDisposableBeanIfNecessary(beanName, bean, mbd); return exposedObject;&#125; createBeanInstance1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123; // Make sure bean class is actually resolved at this point. // 先创建class对象，反射的套路。利用bean的class属性进行反射，所以class属性一定要是bean的实现类 Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); // class如果不是public的，则抛出异常。因为没法进行实例化 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Bean class isn't public, and non-public access not allowed: " + beanClass.getName()); &#125;// 使用FactoryBean的factory-method来创建，支持静态工厂和实例工厂 if (mbd.getFactoryMethodName() != null) &#123; return instantiateUsingFactoryMethod(beanName, mbd, args); &#125; // Shortcut when re-creating the same bean... // 无参数情况时，创建bean。调用无参构造方法 boolean resolved = false; boolean autowireNecessary = false; if (args == null) &#123; synchronized (mbd.constructorArgumentLock) &#123; if (mbd.resolvedConstructorOrFactoryMethod != null) &#123; resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; &#125; &#125; &#125; if (resolved) &#123; if (autowireNecessary) &#123; // autoWire创建 自动装配 return autowireConstructor(beanName, mbd, null, null); &#125; else &#123; // 普通创建 return instantiateBean(beanName, mbd); &#125; &#125; // Need to determine the constructor... // 有参数情况时，创建bean。先利用参数个数，类型等，确定最精确匹配的构造方法。 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; return autowireConstructor(beanName, mbd, ctors, args); &#125; // No special handling: simply use no-arg constructor. // 有参数时，又没获取到构造方法，则只能调用无参构造方法来创建实例了(兜底方法) return instantiateBean(beanName, mbd);&#125; 12345678910111213141516171819protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123; Object beanInstance; final BeanFactory parent = this; if (System.getSecurityManager() != null) &#123; beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; // 创建实例 return getInstantiationStrategy().instantiate(mbd, beanName, parent); &#125; &#125;, getAccessControlContext()); &#125; else &#123; beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); &#125; BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw;&#125; instantiate1234567891011121314151617181920212223242526272829303132333435363738public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123; // Don't override the class with CGLIB if no overrides. if (bd.getMethodOverrides().isEmpty()) &#123; Constructor&lt;?&gt; constructorToUse; // 保证线程安全情况下，获取Constructor synchronized (bd.constructorArgumentLock) &#123; // 获取构造方法或factory-method constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) &#123; // BeanDefinition中如果没有Constructor或者factory-method，则直接使用默认无参构造方法 final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) &#123; throw new BeanInstantiationException(clazz, "Specified class is an interface"); &#125; if (System.getSecurityManager() != null) &#123; constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123; @Override public Constructor&lt;?&gt; run() throws Exception &#123; return clazz.getDeclaredConstructor((Class[]) null); &#125; &#125;); &#125; else &#123; // 获取默认无参构造方法 constructorToUse = clazz.getDeclaredConstructor((Class[]) null); &#125; bd.resolvedConstructorOrFactoryMethod = constructorToUse; &#125; &#125; // 使用上一步得到的Constructor，反射获取bean实例 return BeanUtils.instantiateClass(constructorToUse); &#125; else &#123; // Must generate CGLIB subclass. return instantiateWithMethodInjection(bd, beanName, owner); &#125;&#125; instantiate方法主要做两件事 确定Constructor或者factory-method 利用Constructor，反射创建bean实例 initializeBeanbean创建完后，容器会对它进行初始化，包括后处理的调用，init-method的调用等 1234567891011121314151617181920212223242526protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; // 回调各种aware method，如BeanNameAware， BeanFactoryAware等 if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; // 回调init-method invokeAwareMethods(beanName, bean); &#125; // 回调beanPostProcessor的postProcessBeforeInitialization()方法 Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; invokeInitMethods(beanName, wrappedBean, mbd); if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 由此可见，initializeBean(),也就是bean的初始化流程为 回调各种aware method，如BeanNameAware，将容器中相关引用注入到bean中，供bean使用 回调beanPostProcessor的postProcessBeforeInitialization(), 后处理器的初始化前置调用 回调init-method， 注解和XML中都可以声明 回调beanPostProcessor的postProcessAfterInitialization()方法，后处理器的初始化后置调用。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring启动流程]]></title>
    <url>%2F2018%2F08%2F21%2Fspring%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[web容器加载web.xml中的ContextLoaderListener 初始化spring容器 加载配置文件，创建bean Web.xmlweb容器为spring提供了宿主环境Servletcontext,启动时读取web.xml/包括ContextLoaderListener启动spring容器、DispathcherServlet springmvc分发器， 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!--web项目中上下文初始化参数, name value的形式 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--ContextLoaderListener,会通过它的监听启动spring容器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--DispatherServlet,前端MVC核心，分发器，SpringMVC的核心--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;/web-app&gt; web容器的初始化过程： web容器（如tomcat）读取web.xml, 读取文件中两个节点和 容器创建ServletContext，它是web的上下文，整个web项目都会用到它 读取context-param节点，它以 键值对的形式出现。将节点值转化为键值对，传给ServletContext 容器创建中的实例，创建监听器。监听器必须继承ServletContextListener 调用ServletContextListener的contextInitialized()方法，spring容器的创建和初始化就是在这个方法中 initWebApplicationContext初始化spring容器，使用默认的配置文件，或者context-params中的配置contextConfigLocation org.springframework.web.context.ContextLoader#initWebApplicationContext 123456789101112131415161718192021222324252627282930313233343536373839404142public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123; long startTime = System.currentTimeMillis(); // Store context in local instance variable, to guarantee that // it is available on ServletContext shutdown. //创建WebApplicationContext if (this.context == null) &#123; this.context = createWebApplicationContext(servletContext); &#125; if (this.context instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc // 判断context有没有父context， //取决于web.xml配置文件中locatorFactorySelector参数，如果有父context，则加载它 if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; // determine parent for root web application context, if any. ApplicationContext parent = loadParentContext(servletContext); cwac.setParent(parent); &#125; // refresh容器，这一步会创建beans configureAndRefreshWebApplicationContext(cwac, servletContext); &#125; &#125; // 将spring容器context，挂载到servletContext这个web容器全局变量中。ServletContext是web容器的上下文 //web容器指的是Tomcat等部署web应用的容器，不要和spring容器搞混了 servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); // 将spring容器context赋值给currentContext变量，保存下来 ClassLoader ccl = Thread.currentThread().getContextClassLoader(); if (ccl == ContextLoader.class.getClassLoader()) &#123; currentContext = this.context; &#125; else if (ccl != null) &#123; currentContextPerThread.put(ccl, this.context); &#125; log..... return this.context;&#125; initWebApplicationContext()主要做三件事 创建WebApplicationContext，通过createWebApplicationContext()方法 加载spring配置文件，并创建beans。通过configureAndRefreshWebApplicationContext()方法 将spring容器context挂载到ServletContext 这个web容器上下文中。通过servletContext.setAttribute()方法。 createWebApplicationContext 创建spring容器初始化root webAppLicationContext，采用默认配置或者自定义的class 1234567891011protected WebApplicationContext createWebApplicationContext(ServletContext sc) &#123; // 获取WebApplicationContext实现类的class对象，WebApplicationContext只是一个接口，需要有具体的实现类，默认的实现类是XmlWebApplicationContext Class&lt;?&gt; contextClass = determineContextClass(sc); // 自定义WebApplicationContext必须继承自ConfigurableWebApplicationContext if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException("Custom context class [" + contextClass.getName() + "] is not of type [" + ConfigurableWebApplicationContext.class.getName() + "]"); &#125; // 由class对象创建实例对象 return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);&#125; configureAndRefreshWebApplicationContext 加载spring配置文件，创建beans12345678910111213141516171819protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123; wac.setId(idParam); wac.setServletContext(sc); String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM); if (configLocationParam != null) &#123; wac.setConfigLocation(configLocationParam); &#125; // The wac environment's #initPropertySources will be called in any case when the context // is refreshed; do it eagerly here to ensure servlet property sources are in place for // use in any post-processing or initialization that occurs below prior to #refresh //加载属性到enviroment ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) &#123; ((ConfigurableWebEnvironment) env).initPropertySources(sc, null); &#125; //个性化配置 customizeContext(sc, wac); wac.refresh();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243//读取配置文件、并创建和初始化beanspublic void refresh()&#123; // Prepare this context for refreshing. //准备工作，设置ApplicationContext中的一些标志位，如closed设为false,activer为true,等 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. //读取spring xml配置文件， ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. //设置容器beanfactory的各种成员属性，比如beanCLassLoader,beanPostProcessors //这里的beanPostProcessor都是系统默认的，不是用户自定义的。比如负责注入ApplicationContext引用到各种Aware中的ApplicationContextAwareProcessor容器后处理器。 prepareBeanFactory(beanFactory); // Allows post-processing of the bean factory in context subclasses. // 调用默认的容器后处理器，如ServletContextAwareProcessor postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 初始化并调用所有注册的容器后处理器BeanFactoryPostProcessor invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. // 注册bean后处理器，将实现了BeanPostProcessor接口的bean找到。 //先将实现了PriorityOrdered接口的bean排序并注册到容器BeanFactory中， //然后将实现了Ordered接口的排序并注册到容器中，最后注册剩下的。 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. // 初始化MessageSource，用来处理国际化。 //如果有beanName为“messageSource”，则初始化。否则使用默认的。 initMessageSource(); // Initialize event multicaster for this context. // 初始化ApplicationEventMulticaster，用来进行事件广播。 //如果有beanName为"applicationEventMulticaster"，则初始化它。否则使用默认的SimpleApplicationEventMulticaster。广播事件会发送给所有监听器，也就是实现了ApplicationListener的类 //关于spring事件体系，可以参见 http://blog.csdn.net/caihaijiang/article/details/7460888 initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. // 初始化其他特殊的bean。子类可以override这个方法。如WebApplicationContext的themeSource onRefresh(); // Check for listener beans and register them. // 注册事件监听器，也就是所有实现了ApplicationListener的类。会将监听器加入到事件广播器ApplicationEventMulticaster中，所以在广播时就可以发送消息给所有监听器了。 registerListeners(); // 初始化所有剩下的singleton bean(没有标注lazy-init的) finishBeanFactoryInitialization(beanFactory); // 回调LifecycleProcessor，发送ContextRefreshedEvent事件等 finishRefresh();&#125; 参考文献https://blog.csdn.net/u013510838/article/details/75066884 https://blog.csdn.net/moshenglv/article/details/53517343 http://www.cnblogs.com/ITtangtang/p/3978349.html http://www.linkedkeeper.com/1054.html]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc基本原理]]></title>
    <url>%2F2018%2F08%2F21%2Fspringmvc%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Spring 面试题 Spring MVC基本原理 总结 Spring 面试题 什么是Spring框架，主要模块 好处 IOC,DI BeanFactory和ApplicationContext有什么区别 Spring Bean的生命周期 Spring框架中的单例bean是线程安全的吗 Spring MVC基本原理配置阶段web.xmlDispatcherServlet:Springweb开发的入口 application.xml配置spring启动所需要的加载的bean url-pattern拦截的地址 初始化阶段servlet的init方法由web容器自动调用servlet的init方法，在init方法中，执行初始化操作 加载配置文件加载application.xml，扫包，将className收集起来 初始化IOC容器就是一个map&lt;String,Object&gt; IOC容器规则 key默认都是类名首字母小写 如果用户自定义名字，那么要优先设为该名字 如果是接口，使用接口类型作为key,vlaue为实现类 依赖注入@Autowried 遍历IOC容器中class的属性，是否有注解，将其与容器中的关联 初始化handlermapping map&lt;String,handler&gt;,存储requestmapping配置的url等 list中存储映射关系，包括正则url,参数， 将ioc中被controller注解的class中的url作为baseUrl，其中的方法为url后缀 远行阶段servlet.service(Request,Response)线程阻塞，用户请求，封装参数，反射自动调用方法 request.getURL()获得用户请求的URL 匹配URL和对应的Method调用method封装参数，反射动态调用method 利用Response将调用结果输出到浏览器]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用linux命令]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%B8%B8%E7%94%A8linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux 实用命令： 帮助命令 :man,help 文件目录类：pwd\ls\cd\mkdir\rmdir\touch\cp\rm\mv\cat\more\less\echo\head\tail\ln\history 时间日期类：date\cal 搜索查找类：find\locate\grep 压缩和解压类：gzip\tar 帮助命令man,help 文件目录类定位：pwd\ls\cd\ 目录操作mkdir\rmdir\touch\cp\rm\mv\ 查看less\echo\head\tail\ln\history 时间日期类date\cal 搜索查找类find\locate\grep 压缩和解压类​ gzip\tar]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Guava学习笔记]]></title>
    <url>%2F2018%2F08%2F05%2FGoogle-Guava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介 基本工具 集合Collections 缓存Caches 函数式风格 并发Concurrency 字符串处理Strings 原生类型 区间Ranges I/O hash 事件总线EventBus 数学运算Math 反射Reflections 简介源码包的简单说明 com.google.common.annotations：普通注解类型。 com.google.common.base：基本工具类库和接口。 使用和避免使用null 前置条件：快速失败 常见的对象方法：简化Object常用方法的实现 排序：fluent comparator比较器，提供多关键字排序 Throwable类：简化异常检查和错误传播 com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存 com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类 Immutable collections(不变的集合)：不可修改的集合 新集合类型：multisets，multimaps，tables， bidirectional maps等 集合工具类 拓展工具类：给集合对象添加功能 com.google.common.eventbus：发布订阅风格的事件总线。 com.google.common.hash： 哈希工具包。 com.google.common.io：I/O工具包。 com.google.common.math：原始算术类型和超大数的运算工具包。 com.google.common.net：网络工具包。 com.google.common.primitives：八种原始类型和无符号类型的静态工具包。 com.google.common.reflect：反射工具包。 com.google.common.util.concurrent：多线程工具包。 基本工具Optional 类：使用和避免使用null参见java8 Optional 前置条件：快速失败常见的对象方法：简化Object常用方法的实现排序：fluent comparator比较器，提供多关键字排序Throwable类：简化异常检查和错误传播集合Immutable collections(不变的集合)新集合类型：集合工具类拓展工具类：给集合对象添加功能缓存适用性guava cache与concurrentmap类似，区别在于不会一直保存所有添加的元素，通常都设定为自动回收元素 适用于： 消耗一些内存空间来提升速度 某些健会被查询不止一次 cache实例通过chachebuilder生成器模式获取，但是自定义缓存才是最有趣的地方 加载获取的值如何与健关联 使用cacheLoader（首选，更容易推断所有缓存内容的一致性） 调用get时传入一个callable实例：“get-if absent-compute”的原子语义 cache.put方法 CacheLoader123456789101112131415161718192021222324LoadingCache&lt;String,String&gt; cache = CacheBuilder.newBuilder() .maximumSize(100) .build(new CacheLoader&lt;String, String&gt;() &#123; @Override public String load(String s) throws Exception &#123; if("1".equals(s))&#123; return "1"; &#125;else&#123; return null; &#125; &#125; &#125;);@Testpublic void g1()&#123; try &#123; String s = cache.get("1"); System.out.println(s); String s1 = cache.get("2");//返回null 报异常 CacheLoader returned null for key 2. System.out.println(s); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; Callable123456789101112131415161718192021Cache&lt;String,String&gt; cache = CacheBuilder.newBuilder() .maximumSize(100) .build();@Testpublic void g1()&#123; try &#123; String s = cache.get("1", new Callable&lt;String&gt;() &#123;//每次get都有这个计算过程，调用少的话可硬用，但是call返回null依然是有问题的 @Override public String call() throws Exception &#123; if("1".equals("1"))&#123; return "1"; &#125;else&#123; return null; &#125; &#125; &#125;); System.out.println(s); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; 显式插入cache.put(key, value) 可以直接向缓存中插入值，直接覆盖掉给定健的值 Cache.asMap()视图提供的任何方法也能修改缓存 ，但任何方法都不能原子执行 使用之前要注意使用putIfAbsent(K，V),等 缓存回收基于容量回收、定时回收、和基于引用回收 基于容量回收maximumSize(long), 超过上限尝试回收最近没有使用或者总体上很少使用的缓存项 不同的缓存项有不同的权重，如果你的缓存值，占据完全不同的内存空间，可以使用weigher(weigher)指定一个权重函数（计算key的权重），并且用maxumumnweight(long)指定最大总重 定时回收 expireAfterAccess(long,timeUnit):缓存项在给定时间内灭有被读写访问则回收，缓存的回收顺序和基于大小回收一样 expiredAfterwrite(long,timeunit):缓存项在给定时间内没有被写访问，则回收，如果任务缓存数据总是在固定时间后变得陈旧，这种方式是可取的 基于引用回收通过使用弱引用的健、或弱引用的值、或软引用的值 显示清除任何时候都可以显示清除 监听器CacheBuilder.removalListener(RemovalListener) ：声明一个监听器缓存项被移除时做一些额外的动作 有异步方法 清理不会自动执行清理和回收工作、会在写或者读的时候做一些维护工作，原因在于维护线程要新建，减少与用户操作竞争共享锁 可以自己创建维护线程，以固定的时间调用chche.cleanup（） 刷新chche.refresh（K）为健加载新值,读操作返回原值，与回收不同，回收会等待新值加载完成 其他特性统计缓存命中率，加载新增的平均时间，缓存被回收的总数等 函数式风格并发ListenableFutureService字符串处理原生类型区间I/Ohash事件总线数学运算反射参考文献 官网 https://github.com/google/guava/wiki 并发编程网 http://ifeve.com/google-guava/ http://www.cnblogs.com/peida/p/Guava.htm]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Powermockto]]></title>
    <url>%2F2018%2F08%2F04%2FPowermockto%2F</url>
    <content type="text"><![CDATA[mock是模拟对象，用于模拟真实对象的行为powermock拓展了esaymock和mockito框架，增加了对static 和final方法mock支持等功能， 本文阐述powermockto简单用法，未包含 spy,captor等 jar包123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-module-junit4&lt;/artifactId&gt; &lt;version&gt;1.6.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.powermock&lt;/groupId&gt; &lt;artifactId&gt;powermock-api-mockito&lt;/artifactId&gt; &lt;version&gt;1.6.3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; mock流程 创建一个mock对象 期望：记录希望mock对象有的行为，通常是伪造的部分 回放（replay）：调用我们的测试的代码 验证（Verfications）:验证结果注解概述@RunWith(PowerMockRunner.class)12345@Before public void initMocks() &#123; //注解初始化 MockitoAnnotations.initMocks(this); &#125; @PrepareForTest({Student.class})如果mock的对象的方法是静态、final、私有方法，将类加到注解数组中 @Mockmock的对象，mock创建一个空白实例，没有属性没有方法 @InjectMocksmock对象自动注入到该测试类中,尝试类型注入，如果有多个类型的mock对象，那么会根据名称进行注入，当注入失败的时候，不会抛出异常 mock普通方法12345678910111213141516171819public class T1 &#123; public boolean isExist(File file)&#123; return file.exists(); &#125;&#125;@Test public void test1()&#123; T1 t1 = PowerMockito.mock(T1.class); when(t1.isExist(any())).thenReturn(true); //会真实的调用，但是返回的是mock的内容，如果不想调用的话 T1 t1 =spy(T1.class);; PowerMockito.doReturn(true).when(t1).isExist(any()); assertTrue(t1.isExist(new File("xx.xml"))); &#125;//不需要写注解 模拟静态方法123456789101112131415161718public class T1 &#123; public static boolean isExist(String path)&#123; File file = new File(path); return file.exists(); &#125;&#125;@RunWith(PowerMockRunner.class)@PrepareForTest(T1.class)public class testMock &#123; @Test public void test1() throws Exception &#123; PowerMockito.mockStatic(T1.class); when(T1.isExist(any())).thenReturn(true); assertTrue(T1.isExist("xx")); &#125;&#125; 模拟final类或方法12345678910111213141516171819public class T1 &#123; public final boolean isExist(String path)&#123; File file = new File(path); return file.exists(); &#125;&#125;@RunWith(PowerMockRunner.class)@PrepareForTest(T1.class)//加注解表明final的类public class testMock &#123; @Test public void test1() throws Exception &#123; T1 t1 = PowerMockito.mock(T1.class); when(t1.isExist(any())).thenReturn(true); assertTrue(t1.isExist("xx")); &#125;&#125; 构造函数1234567891011121314151617181920212223public class T1 &#123; public boolean isExist(String path)&#123; File file = new File(path); return file.exists(); &#125;&#125;@RunWith(PowerMockRunner.class)@PrepareForTest(T1.class)public class testMock &#123; @Test public void test1() throws Exception &#123; T1 t1 = new T1(); File file = PowerMockito.mock(File.class); //使用whenNew 构造file返回值，需要添加两个注解 whenNew(File.class).withAnyArguments().thenReturn(file); when(file.exists()).thenReturn(true); assertTrue(t1.isExist("xx.xml")); &#125;&#125; 模拟私有方法123456789101112131415161718192021public class T1 &#123; private boolean isExist(String path)&#123; File file = new File(path); return file.exists(); &#125; public boolean Exist(String path)&#123; return isExist(path); &#125;&#125;@RunWith(PowerMockRunner.class)@PrepareForTest(T1.class)public class testMock &#123; @Test public void test1() throws Exception &#123; T1 t1 = PowerMockito.mock(T1.class); when(t1.Exist("xx")).thenCallRealMethod(); when(t1,"isExist","xx").thenReturn(true); assertTrue(t1.Exist("xx")); &#125;&#125; doAnswer对method内容进行mock，根据invocation接口进行书写，进而对callmethod进行测试 1234PowerMockito.doAnswer(invocation -&gt; &#123; System.out.println("load commute minutes by db"); return Integer.MAX_VALUE;&#125;).when(configDao).getCommuteMinutesByCityIdAndServiceType(anyInt(), anyInt()); InvocationOnMock 123456789101112131415//获取mock的对象Object getMock();//返回方法Method getMethod();//返回参数Object[] getArguments();/** * Returns casted argument using position * @param index argument position * @param clazz argument type * @return casted argument on position */&lt;T&gt; T getArgumentAt(int index, Class&lt;T&gt; clazz);//调用真实的方法Object callRealMethod() throws Throwable; verfications验证方法调用Mockito.verify(mock).create()验证调用了create方法。 Mockito.verify(mock, Mockito.never()).update();验证没有调用update方法。 验证调用次数Mockito.times(int n) : 准确的验证方法调用的次数:n Mockito.atLeastOnce() : 验证方法至少调用1次 Mockito.atLeast(int n) : 验证方法最少调用n次 Mockito.atMost(int n): 验证方法最多调用n次 Mockito.inOrder:验证方法调用的顺序 原理简述 当某个方法被注解@PrepareForTest注解后，启动该测试用例，会创建一个新的MockclassLoader实例，然后加载测试用例用到的类（系统类除外） 加载过程中，会根据mock请求修改mock的class文件，eg,去掉final标识，修改方法体 对于系统类，会修改调用系统类的class文件，不会直接修改系统类class 参考文献 https://www.cnblogs.com/IamThat/p/5072499.html https://blog.csdn.net/qisibajie/article/details/79068086#mockito%E5%92%8Cpowermock%E7%9A%84%E7%94%A8%E6%B3%95 http://hotdog.iteye.com/blog/937862 https://blog.csdn.net/vipshop_fin_dev/article/details/79439334]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8学习笔记]]></title>
    <url>%2F2018%2F08%2F01%2Fjava8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Lambda表达式 函数式接口 方法引用和构造器引用 Stream APi 接口中的默认方法与静态方法 新时间日期API 其他新特性 新特性简介 速度更快 hashmap 1.7数组链表 1.8数组链表-红黑树 ConcurrentHashMap 1.7 分段锁 1.8cas无锁算法 内存结构变化 1.7方法区是永久区的一部分，存放加载的类信息等 1.8把永久区去掉了，并将方法区叫做元空间MetaSpace,并使用物理内存 代码更少（Lambda表达式） 强大的Stream API（像sql一样简单） 便于并行 最大化减少空指针异常Optional Lambda为什么使用Lambda是一个匿名函数=====一段可以传递的代码 example1: 123456789//匿名内部类Comparator&lt;Integer&gt; com = new Comparator&lt;Integer&gt;()&#123; public int compare(Integer o1,Integer o2)&#123; return Integer.compare(o1,o2); &#125;&#125;;//lambdaComparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y);TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(com); example 2: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class TestLambda &#123; /** * 一堆员工中工资大于900的 * 一堆员工中工资大于900的，但是年龄小于18岁的 */ /** * 方案1： * 遍历，各种遍历 * 方案2： * 策略模式以及优化的匿名内部类 * 方案3： * java8函数式编程 */ List&lt;Persion&gt; persions ; @Before public void testBefore()&#123; persions = Arrays.asList( new Persion("zs",16,1299), new Persion("ls",19,799), new Persion("ww",17,1999), new Persion("zl",20,1999), new Persion("tq",18,699) ); &#125; //方案1 @Test public void test1()&#123; ArrayList&lt;Persion&gt; result = new ArrayList&lt;Persion&gt;(); for (Persion p : this.persions) &#123; if(p.getSalary()&gt;800)&#123; result.add(p); &#125; &#125; System.out.println(JSONObject.toJSONString(result)); //如果再加条件，那么就再一个方法遍历多个条件，缺点：代码重复，核心代码没几行 &#125; //方案2 @Test public void test2()&#123; MyPredicate&lt;Persion&gt; myPredicate = new MyPredicate&lt;Persion&gt;() &#123; public boolean test(Persion persion) &#123; return persion.getSalary()&gt;900; &#125; &#125;; ArrayList&lt;Persion&gt; result = new ArrayList&lt;&gt;(); for (Persion p : this.persions) &#123; if(myPredicate.test(p))&#123; result.add(p); &#125; &#125; System.out.println(JSONObject.toJSONString(result)); //主逻辑不需要变，但是还需要写接口之类的 &#125; @Test public void test3()&#123; MyPredicate&lt;Persion&gt; myPredicate = persion -&gt; persion.getSalary()&gt;900; ArrayList&lt;Persion&gt; result = new ArrayList&lt;&gt;(); for (Persion p : this.persions) &#123; if(myPredicate.test(p))&#123; result.add(p); &#125; &#125; result.forEach( System.out::println); &#125;&#125; Lambda 基本语法语法格式： 无参数，无返回值 runable example 1//匿名内部类的final问题 有一个参数，无返回值 consume example 有多个参数，有返回值，多条语句 Comparator example 函数式接口接口中只有一个抽象方法的接口，称为函数式接口 @FuncationInterface 对一个数进行运算 example 123456@FuncationInterfaceinterface MyFun&#123; Integer getValue()&#125;//接口 lambda 实现 四大内置核心函数式接口 函数式接口 参数类型 返回类型 用途 Consumer 消费型接口 T void 对类型为T的对象应用操作,包含方法 void accept(T t) Supplier供给型接口 无 T 返回类型为T的对象，包含方法：T get() Function&lt;T,R&gt; 函数型接口 T R 对类型为T的对象应用操作，并返回结果为类型R的对象，包含方法：R apply(T t) Predicate 断言型接口 T boolean 确定类型为T的对象是否满足某约束，并返回boolean值，包含方法 boolean test(T t) 方法引用，构造器引用，数组引用方法引用​ 若Lambda体中的内容有方法已经实现了，我们可以使用“方法引用”（可以理解为方法引用是Lambda表达式的另外一种表现形式） 语法格式可以使用方法引用的前提是 实现的接口的参数和返回值 与 调用方法的参数与返回值一样 对象：：实例方法名 类：：静态方法名 类：：实例方法名 第一个参数是方法的调用者，第二个是方法的参数值 example 123456789101112131415161718@Test public void test5()&#123; Consumer&lt;String&gt; con = (s) -&gt; System.out.println(s); PrintStream out = System.out; Consumer&lt;String&gt; con1 = out :: println; &#125; @Test public void test6()&#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x,y); Comparator&lt;Integer&gt; com1 = Integer::compare; &#125; @Test public void test7()&#123; BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y); BiPredicate&lt;String,String&gt; bp1 = String::equals; &#125; 构造器引用语法格式CLassName:: new 需要调用的构造器的参数列表要与函数式接口中方法的参数列表保持一致 12345@Test public void test8()&#123; Supplier&lt;Persion&gt; sup = ()-&gt;new Persion(); Supplier&lt;Persion&gt; sup1 = Persion::new; &#125; 数组引用语法格式Type:new 12345@Test public void test10()&#123; Function&lt;Integer,String[]&gt; fun = (x) -&gt; &#123;new String[x]&#125;; Function&lt;Integer,String[]&gt; fun1 = String[]::new; &#125; Stream是java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤、和映射数据等操作。 数据源：集合、数组等 管道：流水线式的中间操作，筛选、切片等 产生一个新流（终端操作）：跟原数据源没有关系 注意： 不会存储元素 不会改变原对象 延迟执行，需要执行结果才执行 创建Stream方法 通过Collection系列集合提供的stream（）、parallelStream()(串行流和并行流) 通过Arrays中的静态方法stream()获取数组流 通过Stream中的静态方法of(T t) 创建无限流 迭代，Stream.iterator(seed,unaryOPerator) 生成，Stream.generator… 并行流与串行流并行流就是把一个内容分成一个多个数据库，并用不同的线程分别处理每个数据块的流，可以声明式的通过parallel()与sequential()在并行流与顺序流之间进行切换。联系Fork/Join框架。 中间操作筛选与切片 方法 描述 filter(Predicate p) 接收Lambda,从流中排除某些元素 distinct() 筛选，通过流所生成元素的hashcode()和equals去除重复元素 limit(long maxSize) 截断，使元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前n个元素的流，若流中元素不足n个，则返回一个空流，与limit(n)互补 映射将流中的元素通过函数映射为其他流 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每一个元素上，并将其映射一个新的元素 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream mapToint(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStremam mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream flatMap(Function f) 接收一个函数作为参数，将流中的每个值换成另外一个流，然后把所有的流连接成一个流 排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator comp) 产生一个新流，其中按比较器顺序排序 终端操作终端操作会从流的流水线生成结果，其结果可以是任何不是流的值，例如，list,Integer,void等 查找与匹配 方法 描述 addMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Preducate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findany() 返回当前流中的任意元素 归约与收集 方法 描述 reduce(T identity,BinaryOperatore)、reduce(BinaryOperator) 将流中元素反复结合起来，得到一个值 collect(Collector c) 将流转换为其他形式，接收一个Collector接口是实现，用于给Stream中元素做汇总 optional容器类代表一个值存在或不存在，原来用null表示一个值不存在，现在Optional 可以更好的表达这个概念，并且可以避免空指针异常。 常用方法 方法 描述 Optional.of(T) 创建指定引用的Optional实例，若引用为null则快速失败 Optional.absent() 创建一个空的Optional实例 Optional.ofNullable() 若t不为null,创建Optinal实例，否则创建空实例 boolean isPresent() 判断是否包含值 T orElse(T other) 如果调用对象包含值，返回值，否则返回other T orElseGet(Supplier&lt;? extends T&gt; other) 如果调用对象包含值，返回该值，否则返回other获取到的值 Optional map(Function&lt;? super T, ? extends U&gt; mapper) 如果有值对其处理，并返回处理后的optinal,否则返回Optional.empty() Optional flatMap(Function&lt;? super T, Optional&gt; mapper) 与map类似 有点鸡肋，麻烦的狠 接口优化默认方法 实现多接口，如果都有默认方法实现，必须在当前的类中对方法进行覆写 静态方法接口中可以有静态方法 日期时间API代办 重复注解与类型注解重复注解：在一个类上重复定义一个注解，该注解的注解需要标注为@Repeatables]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet学习笔记]]></title>
    <url>%2F2018%2F07%2F30%2FServlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[servlet 容器 Servlet体系结构 servlet容器常见的Servlet容器是tomcat，jetty等 tomcat容器模型 tomcat容器分为四个等级，真正管理servlet的容器是Context容器，一个Context对应一个web工程 tomcat添加一个web项目12345678910111213public Context addWebapp(Host host, String url, String path) &#123; //silence(url); Context ctx = new StandardContext(); ctx.setPath( url );//设置访问路径 ctx.setDocBase(path);//设置项目路径 ctx.setRealm(new NullRealm());//设置权限 ctx.addLifecycleListener(new Tomcat.DefaultWebXmlListener()); ContextConfig ctxCfg = new ContextConfig(); ctx.addLifecycleListener(ctxCfg); ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML"); host.addChild(ctx);//添加到host父容器中 return ctx; &#125; tomcat 启动容器初始化应用初始化 主要是解析web.xml文件，解析文件中的属性保存到WebXML对象中， 然后将WebXML对象中的属性设置到Context中，这里包括Servlet，filter,listener等 Servlet将被包装成Context容器中的StandardWrapper，其具有容器的特征，转换将使得开发者不需要强耦合tomcat 创建servlet实例 创建Servlet对象 如果Servlet的load-on-startup配置项大于0，那么context容器启动的时候就会被实例化，例如DefaultServlet和JSPServlet 调用wrapper.loadServlet方法：获取servletclasss交给instanceManager去创建一个机遇servletclass.class对象 初始化Servlet 调用servlet的init方法，同时把包装了Standandwrapper对象de standardwrapperfacade作为servletconfig传给Servlet Servlet体系结构servlet​ Servlet 的运行模式是一个典型的“握手型的交互式”运行模式。所谓“握手型的交互式”就是两个模块为了交换数据通常都会准备一个交易场景，这个场景一直跟随个这个交易过程直到这个交易完成为止。这个交易场景的初始化是根据这次交易对象指定的参数来定制的，这些指定参数通常就会是一个配置类。所以对号入座，交易场景就由 ServletContext 来描述，而定制的参数集合就由 ServletConfig 来描述。而 ServletRequest 和 ServletResponse 就是要交互的具体对象了，它们通常都是作为运输工具来传递交互结果。 与servlet主动关联的三个类：Servletconfig、servletRequest和ServletResponse,这三个类都是通过容器传递给Servlet的。servletconfig是在servlet是Serevlet初始化时候 传递，后两个是请求到达的时候传递过来的。 Servletconfig接口声明的方法是为了获取Servlet的一些配置信息，包括servletcontext ServletRequest和ServletResponse是请求响应使用,由tomcat将请求封装为org.apache.coyote.Request ，交给一个用户线程处理请求会创建org.apache.catalina.connector. Request ，穿越整个Servlet容器直到传给Servlet，传递给的是request的门面类requestfacade servletconfig standardwrapper和standardwrapperfacade都实现了servletconfig接口，而standwrapperfacade是门面类，传递给servlet,这个类能够保证从 StandardWrapper 中拿到 ServletConfig 所规定的数据，而又不把 ServletConfig 不关心的数据暴露给 Servlet servletconfg 湖区servletcontext的实际对象是ApplicationContextFacade对象，对容器数据的封装 参考文献Servlet 工作原理解析 https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[listener学习笔记]]></title>
    <url>%2F2018%2F07%2F30%2FListener%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[listener定义，以及三大分类等 定义监听器listener就是在application、session\request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件 分类 类型 接口方法 接收事件 ServletContextListener 接口 Servlet上下文事件 contextInitialized() 与 contextDestroyed() ServletContextEvent ServletContextAttributeListene Servlet上下文事件 attributeAdded() 、 attributeReplaced() 、 attributeRemoved() ServletContextAttributeEvent HttpSessionListener 会话事件 sessionCreated() 与 sessionDestroyed () HttpSessionEvent HttpSessionAttributeListener 会话事件 attributeAdded() 、 attributeReplaced() 、 attributeRemoved() HttpSessionBindingEvent HttpSessionActivationListener 会话事件 sessionDidActivate() 与 sessionWillPassivate() HttpSessionEvent HttpSessionBindingListener 会话事件 valueBound() 与 valueUnbound() ServletRequestListener 请求事件 requestInitialized() 与 requestDestroyed() RequestEvent ServletRequestAttributeListener 请求事件 attributeAdded() 、 attributeReplaced() 、 attributeRemoved() ServletRequestAttributeEvent 举例在web.xml中添加 123&lt; listener &gt; &lt; listener -class &gt; com.servlet .listener .YouAchieveListener &lt; /listener -class &gt;&lt; /listener &gt; 在线人数思路：配置listener实现httpsessionListener,sessionCreated的时候执行 spring启动12345678&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;&lt;!-- 采用的是通配符方式，查找WEB-INF/spring目录下xml文件。如有多个xml文件，以“,”分隔。 --&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; ​ ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。 ContextLoaderListener如何查找ApplicationContext.xml的配置位置以及配置多个xml：如果在web.xml中不写任何参数配置信息，默认的路径是”/WEB-INF/applicationContext.xml”，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml（在MyEclipse中把xml文件放置在src目录下）。如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数。 原理观察者模式的实现，在web。xml中配置listener的时候就是把一个被观察者放入到观察者对象列表中，当被观察者触发了注册事件时观察者作出相应的反应。在容器container中注册呼叫特定的实现类 参考文献https://my.oschina.net/ydsakyclguozi/blog/398403 https://www.cnblogs.com/hellojava/archive/2012/12/26/2833840.html http://even2012.iteye.com/blog/1963467]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ContextLoaderListener & DispatcherServlet]]></title>
    <url>%2F2018%2F07%2F29%2FContextLoaderListener-DispatcherServlet%2F</url>
    <content type="text"><![CDATA[ContextLoaderListener, DispatcherServlet都会加载配置文件, 那么二者之间有什么区别？ 两个配置文件之间的差异，各定义什么bean 两个类的继承体系结构 两个配置文件生成的容器之间的关系 Spring 与 web.xmlspring 提供了强大的IOC能力，我们往往会配置业务层，数据层的bean在容器中；除此之外，spring 特提供了spring mvc，控制前段发送的请求，在web.xml中往往会有以下的代码片段。 1234567891011121314151617181920&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:*-context.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;servlet&gt; &lt;servlet-name&gt;platform-services&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:platform-services-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;... ContextLoadListener ContextLoaderListener加载设置的配置文件, 联系ServletContextListener监听器 DispatcherServlet DispatcherServlet记载设置的配置文件, 联系ServletConfig ContextLoaderListener​ 继承体系结构 ContextLoaderListener继承ContextLoader, 实现了ServletContextListener接口. 因此在Web容器启动的时候, 其会监听到ServletContext创建事件, 进而进行初始化操作, 其加载配置文件的本质工作是通过ContextLoader来实现的。 ​ initWebApplicationContext()根据指定的xml文件初始化root WebAppicationContext. 在没有设置的,即自定有 上下文初始化类的情况下, 默认采用XmlWebApplicationContex来初始化Spring容器. 此容器是root容器, 里面一般包含应用程序可以共享的bean, 例如 业务层, 数据层, 工具层等等, 往往不会涉及到Web相关的组件, 如视图解析器, 控制器….. root容器被设置在ServletContext中 12345678910111213public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123; public ContextLoaderListener(WebApplicationContext context) &#123; super(context); &#125; /** * Initialize the root web application context. */ @Override public void contextInitialized(ServletContextEvent event) &#123; initWebApplicationContext(event.getServletContext()); &#125; &#125; DispatcherServlet​ 集成体系结构 从集成体系结构可以看出, DispatcherServlet本质上市基于Servlet, 因此也就包含Servlet的生命周期方法, 例如, init(), getServletConfig(), service() HttpServletBean读取web.xml中的DispatcherServlet的配置信息, ; 同时留给子类一些接口实现其他的功能 FramewordServlet则是初始化web application context, 每一个DIspatcherServlet都有一个与之对应的web application context. 其父类是ContextLoader初始化的 Spring上下文(root web application context) DispatcherServlet则用户初始化Spring MVC框架其他的组件, 如HandlerMapping…. 1234HttpServlet HttpServletBean FramewordServlet DispactherServlet 两者初始化的上下文之间的关系​ 上下文的关系如下 父子关系, Spring允许用户建立容器之间的多级关系, 子容器(DispatcherServlet初始化的容器)在本容器中找不到Bean时, 将会去父容器中查找. 父容器中的bean将 在所有子容器之间共享。 常见问题 同一个Bean初始化多遍 将root web application context与web application context的配置信息放在一起 一个bean不仅使用注解, 也使用xml配置以便 在拦截器或者监听器中使用XmlWebApplicationContext加载配置文件….]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>servlet</tag>
        <tag>listener</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客]]></title>
    <url>%2F2018%2F07%2F28%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[在github pages搭建hexo风格的博客，next主题,多电脑方便使用 搭建全新的博客安装git，github创建个人仓库用户名.github.io 安装node.js官网下载地址：https://nodejs.org/zh-cn/download/ 安装成功后在命令窗输node –version显示版本号 安装Hexohttps://zhuanlan.zhihu.com/p/26625249 添加搜索功能http://www.itfanr.cc/2017/10/27/add-search-function-to-hexo-blog/ 修改宽度https://www.heqiangfly.com/2016/01/12/blog-optimize-next-theme/ 关于我页面http://www.5isjyx.com/coding/201704/hexonextabout.html 分类与标签https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/ 评论https://www.bluelzy.com/articles/use_valine_for_your_blog.html 阅读次数http://www.yangyong.xyz/2018/01/03/add-hexo-next-post-views/ 新电脑搭建博客https://www.titanjun.top/2018/04/12/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86/ 目前的操作 clone hexo分支 （新电脑） npm install（新电脑） 写博客 hexo n “博客名” hexo g 生成博客 hexo s启动网站 hexo d发布到master 提交hexo内容到hexo分支 关于写博客的注意事项： 摘要 1234标题：。。。摘要内容。。。&lt;!-- more --&gt;内容。。。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来聊啊]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[微信]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
